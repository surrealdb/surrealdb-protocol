// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: surrealdb/protocol/rpc/v1/rpc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Duration } from "../../../../google/protobuf/duration";
import { NullValue, RecordId, Uuid, Value, Variables } from "../../v1/value";

export const protobufPackage = "surrealdb.protocol.rpc.v1";

/** Action type. */
export enum Action {
  UNSPECIFIED = 0,
  CREATED = 1,
  UPDATED = 2,
  DELETED = 3,
  KILLED = 4,
  UNRECOGNIZED = -1,
}

export function actionFromJSON(object: any): Action {
  switch (object) {
    case 0:
    case "ACTION_UNSPECIFIED":
      return Action.UNSPECIFIED;
    case 1:
    case "ACTION_CREATED":
      return Action.CREATED;
    case 2:
    case "ACTION_UPDATED":
      return Action.UPDATED;
    case 3:
    case "ACTION_DELETED":
      return Action.DELETED;
    case 4:
    case "ACTION_KILLED":
      return Action.KILLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Action.UNRECOGNIZED;
  }
}

export function actionToJSON(object: Action): string {
  switch (object) {
    case Action.UNSPECIFIED:
      return "ACTION_UNSPECIFIED";
    case Action.CREATED:
      return "ACTION_CREATED";
    case Action.UPDATED:
      return "ACTION_UPDATED";
    case Action.DELETED:
      return "ACTION_DELETED";
    case Action.KILLED:
      return "ACTION_KILLED";
    case Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The kind of query response. */
export enum QueryResponseKind {
  UNSPECIFIED = 0,
  /**
   * SINGLE - A single value is contained in the response and no further responses are expected.
   *
   * This is used in the context of `SELECT ONLY ...` or other queries that should only ever return a single value.
   */
  SINGLE = 1,
  /** BATCHED - A batch of values is contained in the response and further responses may be expected. */
  BATCHED = 2,
  /**
   * BATCHED_FINAL - The final response from a batched query. No further responses for this query ID are expected.
   *
   * This response should always contain the query stats.
   *
   * Note: If all response values can fit in a single batch, this will be the first and only response.
   */
  BATCHED_FINAL = 3,
  UNRECOGNIZED = -1,
}

export function queryResponseKindFromJSON(object: any): QueryResponseKind {
  switch (object) {
    case 0:
    case "QUERY_RESPONSE_KIND_UNSPECIFIED":
      return QueryResponseKind.UNSPECIFIED;
    case 1:
    case "QUERY_RESPONSE_KIND_SINGLE":
      return QueryResponseKind.SINGLE;
    case 2:
    case "QUERY_RESPONSE_KIND_BATCHED":
      return QueryResponseKind.BATCHED;
    case 3:
    case "QUERY_RESPONSE_KIND_BATCHED_FINAL":
      return QueryResponseKind.BATCHED_FINAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QueryResponseKind.UNRECOGNIZED;
  }
}

export function queryResponseKindToJSON(object: QueryResponseKind): string {
  switch (object) {
    case QueryResponseKind.UNSPECIFIED:
      return "QUERY_RESPONSE_KIND_UNSPECIFIED";
    case QueryResponseKind.SINGLE:
      return "QUERY_RESPONSE_KIND_SINGLE";
    case QueryResponseKind.BATCHED:
      return "QUERY_RESPONSE_KIND_BATCHED";
    case QueryResponseKind.BATCHED_FINAL:
      return "QUERY_RESPONSE_KIND_BATCHED_FINAL";
    case QueryResponseKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request to check the health of the database. */
export interface HealthRequest {
}

/** Response to a health check request. */
export interface HealthResponse {
}

/** Request to get the version of the database. */
export interface VersionRequest {
}

/** Response to a version request. */
export interface VersionResponse {
  version: string;
}

/** Request to sign up a new user. */
export interface SignupRequest {
  namespace: string;
  database: string;
  accessName: string;
  variables: Variables | undefined;
}

/** Response to a signup request. */
export interface SignupResponse {
  value: Value | undefined;
}

/** Request to sign in a user. */
export interface SigninRequest {
  accessMethod: AccessMethod | undefined;
}

/** Response to a signin request. */
export interface SigninResponse {
  value: Value | undefined;
}

/** Request to authenticate a user. */
export interface AuthenticateRequest {
  token: string;
}

/** Response to an authenticate request. */
export interface AuthenticateResponse {
  value: Value | undefined;
}

/** Request to use a namespace and database. */
export interface UseRequest {
  /**
   * The namespace to use.
   * An empty namespace will unset the current namespace.
   */
  namespace: string;
  /**
   * The database to use.
   * An empty database will unset the current database.
   */
  database: string;
}

/** Response to a use request. */
export interface UseResponse {
  /** The namespace that is now in use. */
  namespace: string;
  /** The database that is now in use. */
  database: string;
}

/** Request to set a global variable for the current session. */
export interface SetRequest {
  /** The name of the variable to set. */
  name: string;
  /** The value to set the variable to. */
  value: Value | undefined;
}

/** Response to a set request. */
export interface SetResponse {
}

/** Request to unset a global variable for the current session. */
export interface UnsetRequest {
  /** The name of the variable to unset. */
  name: string;
}

/** Response to an unset request. */
export interface UnsetResponse {
}

/** Request to invalidate the current session. */
export interface InvalidateRequest {
}

/** Response to an invalidate request. */
export interface InvalidateResponse {
}

/** Request to reset all global variables for the current session. */
export interface ResetRequest {
}

/** Response to a reset request. */
export interface ResetResponse {
}

/** Request to import data into the database. */
export interface ImportSqlRequest {
  statement: string;
}

/** Response to an import request. */
export interface ImportSqlResponse {
}

/** Request to export data from the database. */
export interface ExportSqlRequest {
  users: boolean;
  accesses: boolean;
  params: boolean;
  functions: boolean;
  analyzers: boolean;
  tables: ExportSqlRequest_Tables | undefined;
  versions: boolean;
  records: boolean;
  sequences: boolean;
}

export interface ExportSqlRequest_SelectedTables {
  tables: string[];
}

export interface ExportSqlRequest_Tables {
  selection?: { $case: "all"; all: NullValue } | { $case: "none"; none: NullValue } | {
    $case: "selected";
    selected: ExportSqlRequest_SelectedTables;
  } | undefined;
}

/** Response to an export request. */
export interface ExportSqlResponse {
  statement: string;
}

/** Request to export the ML model. */
export interface ExportMlModelRequest {
  name: string;
  version: string;
}

/** Response to an export request. */
export interface ExportMlModelResponse {
  model: Uint8Array;
}

/** Request to issue a live query. */
export interface SubscribeRequest {
  subscribeTo?: { $case: "liveQueryId"; liveQueryId: Uuid } | { $case: "query"; query: QueryRequest } | undefined;
}

/** Response to a live query. */
export interface SubscribeResponse {
  notification: Notification | undefined;
}

/** A notification from a live query. */
export interface Notification {
  liveQueryId: Uuid | undefined;
  action: Action;
  recordId: RecordId | undefined;
  value: Value | undefined;
}

/** Request to query the database. */
export interface QueryRequest {
  query: string;
  variables: Variables | undefined;
  txnId: Uuid | undefined;
}

/**
 * Streaming response to a query request.
 *
 * When a query has 5 statements, there will be 5 unique query IDs (0..4). Each query
 * ID's response can be assumed to be sent in order, but may be interleaved in the future.
 *
 * Expect only the last response for each query ID to contain the query stats.
 *
 * Responses are ordered by query index, then batch index. For example:
 *  QueryResponse(query_index=0, batch_index=0, stats=None)
 *  QueryResponse(query_index=0, batch_index=1, stats=Some(..))
 *  QueryResponse(query_index=1, batch_index=0, stats=Some(..))
 *  QueryResponse(query_index=2, batch_index=0, stats=None)
 *  QueryResponse(query_index=2, batch_index=1, stats=None)
 *  QueryResponse(query_index=2, batch_index=2, stats=Some(..))
 *  QueryResponse(query_index=3, batch_index=0, stats=Some(..))
 *  QueryResponse(query_index=4, batch_index=0, stats=Some(..))
 */
export interface QueryResponse {
  /** The index of the query result. */
  queryIndex: number;
  /** The index of the batch within the given query. */
  batchIndex: bigint;
  /**
   * The total number of query results.
   *
   * Every response will contain the same value for this field so you can
   * use the value from the first response to determine how many query results
   * to expect.
   *
   * Note: This is NOT the number of records returned.
   *
   * Examples:
   *   query = "SELECT * FROM users;"
   *   result_count = 1
   *
   *   query = """
   *   SELECT * FROM users;
   *   SELECT * FROM posts;
   *   """
   *   result_count = 2
   *
   *   query = """
   *   SELECT * FROM users;
   *   SELECT * FROM posts;
   *   SELECT * FROM comments;
   *   """
   *   result_count = 3
   */
  resultCount: number;
  /** The kind of query response. */
  kind: QueryResponseKind;
  /**
   * The query stats.
   * This is only expected to be present in the last batch of each query.
   */
  stats:
    | QueryStats
    | undefined;
  /** The error, if any. */
  error:
    | QueryError
    | undefined;
  /** A batch of values. */
  values: Value[];
}

/** Query statistics. */
export interface QueryStats {
  /** The number of records returned. -1 if unknown. */
  recordsReturned: bigint;
  /** The number of bytes returned. -1 if unknown. */
  bytesReturned: bigint;
  /** The number of records scanned. -1 if unknown. */
  recordsScanned: bigint;
  /** The number of bytes scanned. -1 if unknown. */
  bytesScanned: bigint;
  /** The duration of the query. */
  executionDuration: Duration | undefined;
}

/** Query error. */
export interface QueryError {
  /** The error code. */
  code: bigint;
  /** The error message. */
  message: string;
}

/** Root user credentials. */
export interface RootUserCredentials {
  username: string;
  password: string;
}

/** Namespace access credentials. */
export interface NamespaceAccessCredentials {
  namespace: string;
  access: string;
  key: string;
}

/** Database access credentials. */
export interface DatabaseAccessCredentials {
  namespace: string;
  database: string;
  access: string;
  key: string;
  refresh: string;
}

/** Namespace user credentials. */
export interface NamespaceUserCredentials {
  namespace: string;
  username: string;
  password: string;
}

/** Database user credentials. */
export interface DatabaseUserCredentials {
  namespace: string;
  database: string;
  username: string;
  password: string;
}

/** Access token. */
export interface AccessToken {
  token: string;
}

/** Method of authenticating with the database. */
export interface AccessMethod {
  method?:
    | { $case: "root"; root: RootUserCredentials }
    | { $case: "namespace"; namespace: NamespaceAccessCredentials }
    | { $case: "database"; database: DatabaseAccessCredentials }
    | { $case: "namespaceUser"; namespaceUser: NamespaceUserCredentials }
    | { $case: "databaseUser"; databaseUser: DatabaseUserCredentials }
    | { $case: "accessToken"; accessToken: AccessToken }
    | undefined;
}

function createBaseHealthRequest(): HealthRequest {
  return {};
}

export const HealthRequest: MessageFns<HealthRequest> = {
  encode(_: HealthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthRequest {
    return {};
  },

  toJSON(_: HealthRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthRequest>, I>>(base?: I): HealthRequest {
    return HealthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthRequest>, I>>(_: I): HealthRequest {
    const message = createBaseHealthRequest();
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return {};
}

export const HealthResponse: MessageFns<HealthResponse> = {
  encode(_: HealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthResponse {
    return {};
  },

  toJSON(_: HealthResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse>, I>>(base?: I): HealthResponse {
    return HealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse>, I>>(_: I): HealthResponse {
    const message = createBaseHealthResponse();
    return message;
  },
};

function createBaseVersionRequest(): VersionRequest {
  return {};
}

export const VersionRequest: MessageFns<VersionRequest> = {
  encode(_: VersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): VersionRequest {
    return {};
  },

  toJSON(_: VersionRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionRequest>, I>>(base?: I): VersionRequest {
    return VersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionRequest>, I>>(_: I): VersionRequest {
    const message = createBaseVersionRequest();
    return message;
  },
};

function createBaseVersionResponse(): VersionResponse {
  return { version: "" };
}

export const VersionResponse: MessageFns<VersionResponse> = {
  encode(message: VersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionResponse {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: VersionResponse): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionResponse>, I>>(base?: I): VersionResponse {
    return VersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionResponse>, I>>(object: I): VersionResponse {
    const message = createBaseVersionResponse();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseSignupRequest(): SignupRequest {
  return { namespace: "", database: "", accessName: "", variables: undefined };
}

export const SignupRequest: MessageFns<SignupRequest> = {
  encode(message: SignupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.database !== "") {
      writer.uint32(18).string(message.database);
    }
    if (message.accessName !== "") {
      writer.uint32(26).string(message.accessName);
    }
    if (message.variables !== undefined) {
      Variables.encode(message.variables, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.database = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accessName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.variables = Variables.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupRequest {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      accessName: isSet(object.accessName) ? globalThis.String(object.accessName) : "",
      variables: isSet(object.variables) ? Variables.fromJSON(object.variables) : undefined,
    };
  },

  toJSON(message: SignupRequest): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.accessName !== "") {
      obj.accessName = message.accessName;
    }
    if (message.variables !== undefined) {
      obj.variables = Variables.toJSON(message.variables);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupRequest>, I>>(base?: I): SignupRequest {
    return SignupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupRequest>, I>>(object: I): SignupRequest {
    const message = createBaseSignupRequest();
    message.namespace = object.namespace ?? "";
    message.database = object.database ?? "";
    message.accessName = object.accessName ?? "";
    message.variables = (object.variables !== undefined && object.variables !== null)
      ? Variables.fromPartial(object.variables)
      : undefined;
    return message;
  },
};

function createBaseSignupResponse(): SignupResponse {
  return { value: undefined };
}

export const SignupResponse: MessageFns<SignupResponse> = {
  encode(message: SignupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupResponse {
    return { value: isSet(object.value) ? Value.fromJSON(object.value) : undefined };
  },

  toJSON(message: SignupResponse): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupResponse>, I>>(base?: I): SignupResponse {
    return SignupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupResponse>, I>>(object: I): SignupResponse {
    const message = createBaseSignupResponse();
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseSigninRequest(): SigninRequest {
  return { accessMethod: undefined };
}

export const SigninRequest: MessageFns<SigninRequest> = {
  encode(message: SigninRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessMethod !== undefined) {
      AccessMethod.encode(message.accessMethod, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigninRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigninRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessMethod = AccessMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigninRequest {
    return { accessMethod: isSet(object.accessMethod) ? AccessMethod.fromJSON(object.accessMethod) : undefined };
  },

  toJSON(message: SigninRequest): unknown {
    const obj: any = {};
    if (message.accessMethod !== undefined) {
      obj.accessMethod = AccessMethod.toJSON(message.accessMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SigninRequest>, I>>(base?: I): SigninRequest {
    return SigninRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SigninRequest>, I>>(object: I): SigninRequest {
    const message = createBaseSigninRequest();
    message.accessMethod = (object.accessMethod !== undefined && object.accessMethod !== null)
      ? AccessMethod.fromPartial(object.accessMethod)
      : undefined;
    return message;
  },
};

function createBaseSigninResponse(): SigninResponse {
  return { value: undefined };
}

export const SigninResponse: MessageFns<SigninResponse> = {
  encode(message: SigninResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigninResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigninResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigninResponse {
    return { value: isSet(object.value) ? Value.fromJSON(object.value) : undefined };
  },

  toJSON(message: SigninResponse): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SigninResponse>, I>>(base?: I): SigninResponse {
    return SigninResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SigninResponse>, I>>(object: I): SigninResponse {
    const message = createBaseSigninResponse();
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseAuthenticateRequest(): AuthenticateRequest {
  return { token: "" };
}

export const AuthenticateRequest: MessageFns<AuthenticateRequest> = {
  encode(message: AuthenticateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateRequest {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: AuthenticateRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateRequest>, I>>(base?: I): AuthenticateRequest {
    return AuthenticateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateRequest>, I>>(object: I): AuthenticateRequest {
    const message = createBaseAuthenticateRequest();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseAuthenticateResponse(): AuthenticateResponse {
  return { value: undefined };
}

export const AuthenticateResponse: MessageFns<AuthenticateResponse> = {
  encode(message: AuthenticateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateResponse {
    return { value: isSet(object.value) ? Value.fromJSON(object.value) : undefined };
  },

  toJSON(message: AuthenticateResponse): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateResponse>, I>>(base?: I): AuthenticateResponse {
    return AuthenticateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateResponse>, I>>(object: I): AuthenticateResponse {
    const message = createBaseAuthenticateResponse();
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseUseRequest(): UseRequest {
  return { namespace: "", database: "" };
}

export const UseRequest: MessageFns<UseRequest> = {
  encode(message: UseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.database !== "") {
      writer.uint32(18).string(message.database);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.database = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UseRequest {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
    };
  },

  toJSON(message: UseRequest): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UseRequest>, I>>(base?: I): UseRequest {
    return UseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UseRequest>, I>>(object: I): UseRequest {
    const message = createBaseUseRequest();
    message.namespace = object.namespace ?? "";
    message.database = object.database ?? "";
    return message;
  },
};

function createBaseUseResponse(): UseResponse {
  return { namespace: "", database: "" };
}

export const UseResponse: MessageFns<UseResponse> = {
  encode(message: UseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.database !== "") {
      writer.uint32(18).string(message.database);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.database = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UseResponse {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
    };
  },

  toJSON(message: UseResponse): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UseResponse>, I>>(base?: I): UseResponse {
    return UseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UseResponse>, I>>(object: I): UseResponse {
    const message = createBaseUseResponse();
    message.namespace = object.namespace ?? "";
    message.database = object.database ?? "";
    return message;
  },
};

function createBaseSetRequest(): SetRequest {
  return { name: "", value: undefined };
}

export const SetRequest: MessageFns<SetRequest> = {
  encode(message: SetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetRequest>, I>>(base?: I): SetRequest {
    return SetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetRequest>, I>>(object: I): SetRequest {
    const message = createBaseSetRequest();
    message.name = object.name ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseSetResponse(): SetResponse {
  return {};
}

export const SetResponse: MessageFns<SetResponse> = {
  encode(_: SetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SetResponse {
    return {};
  },

  toJSON(_: SetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SetResponse>, I>>(base?: I): SetResponse {
    return SetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetResponse>, I>>(_: I): SetResponse {
    const message = createBaseSetResponse();
    return message;
  },
};

function createBaseUnsetRequest(): UnsetRequest {
  return { name: "" };
}

export const UnsetRequest: MessageFns<UnsetRequest> = {
  encode(message: UnsetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnsetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnsetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: UnsetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnsetRequest>, I>>(base?: I): UnsetRequest {
    return UnsetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnsetRequest>, I>>(object: I): UnsetRequest {
    const message = createBaseUnsetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUnsetResponse(): UnsetResponse {
  return {};
}

export const UnsetResponse: MessageFns<UnsetResponse> = {
  encode(_: UnsetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnsetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UnsetResponse {
    return {};
  },

  toJSON(_: UnsetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UnsetResponse>, I>>(base?: I): UnsetResponse {
    return UnsetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnsetResponse>, I>>(_: I): UnsetResponse {
    const message = createBaseUnsetResponse();
    return message;
  },
};

function createBaseInvalidateRequest(): InvalidateRequest {
  return {};
}

export const InvalidateRequest: MessageFns<InvalidateRequest> = {
  encode(_: InvalidateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvalidateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InvalidateRequest {
    return {};
  },

  toJSON(_: InvalidateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<InvalidateRequest>, I>>(base?: I): InvalidateRequest {
    return InvalidateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvalidateRequest>, I>>(_: I): InvalidateRequest {
    const message = createBaseInvalidateRequest();
    return message;
  },
};

function createBaseInvalidateResponse(): InvalidateResponse {
  return {};
}

export const InvalidateResponse: MessageFns<InvalidateResponse> = {
  encode(_: InvalidateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvalidateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InvalidateResponse {
    return {};
  },

  toJSON(_: InvalidateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<InvalidateResponse>, I>>(base?: I): InvalidateResponse {
    return InvalidateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvalidateResponse>, I>>(_: I): InvalidateResponse {
    const message = createBaseInvalidateResponse();
    return message;
  },
};

function createBaseResetRequest(): ResetRequest {
  return {};
}

export const ResetRequest: MessageFns<ResetRequest> = {
  encode(_: ResetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResetRequest {
    return {};
  },

  toJSON(_: ResetRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetRequest>, I>>(base?: I): ResetRequest {
    return ResetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetRequest>, I>>(_: I): ResetRequest {
    const message = createBaseResetRequest();
    return message;
  },
};

function createBaseResetResponse(): ResetResponse {
  return {};
}

export const ResetResponse: MessageFns<ResetResponse> = {
  encode(_: ResetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResetResponse {
    return {};
  },

  toJSON(_: ResetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetResponse>, I>>(base?: I): ResetResponse {
    return ResetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetResponse>, I>>(_: I): ResetResponse {
    const message = createBaseResetResponse();
    return message;
  },
};

function createBaseImportSqlRequest(): ImportSqlRequest {
  return { statement: "" };
}

export const ImportSqlRequest: MessageFns<ImportSqlRequest> = {
  encode(message: ImportSqlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statement !== "") {
      writer.uint32(10).string(message.statement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportSqlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportSqlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statement = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportSqlRequest {
    return { statement: isSet(object.statement) ? globalThis.String(object.statement) : "" };
  },

  toJSON(message: ImportSqlRequest): unknown {
    const obj: any = {};
    if (message.statement !== "") {
      obj.statement = message.statement;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportSqlRequest>, I>>(base?: I): ImportSqlRequest {
    return ImportSqlRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportSqlRequest>, I>>(object: I): ImportSqlRequest {
    const message = createBaseImportSqlRequest();
    message.statement = object.statement ?? "";
    return message;
  },
};

function createBaseImportSqlResponse(): ImportSqlResponse {
  return {};
}

export const ImportSqlResponse: MessageFns<ImportSqlResponse> = {
  encode(_: ImportSqlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportSqlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportSqlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ImportSqlResponse {
    return {};
  },

  toJSON(_: ImportSqlResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportSqlResponse>, I>>(base?: I): ImportSqlResponse {
    return ImportSqlResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportSqlResponse>, I>>(_: I): ImportSqlResponse {
    const message = createBaseImportSqlResponse();
    return message;
  },
};

function createBaseExportSqlRequest(): ExportSqlRequest {
  return {
    users: false,
    accesses: false,
    params: false,
    functions: false,
    analyzers: false,
    tables: undefined,
    versions: false,
    records: false,
    sequences: false,
  };
}

export const ExportSqlRequest: MessageFns<ExportSqlRequest> = {
  encode(message: ExportSqlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.users !== false) {
      writer.uint32(8).bool(message.users);
    }
    if (message.accesses !== false) {
      writer.uint32(16).bool(message.accesses);
    }
    if (message.params !== false) {
      writer.uint32(24).bool(message.params);
    }
    if (message.functions !== false) {
      writer.uint32(32).bool(message.functions);
    }
    if (message.analyzers !== false) {
      writer.uint32(40).bool(message.analyzers);
    }
    if (message.tables !== undefined) {
      ExportSqlRequest_Tables.encode(message.tables, writer.uint32(50).fork()).join();
    }
    if (message.versions !== false) {
      writer.uint32(56).bool(message.versions);
    }
    if (message.records !== false) {
      writer.uint32(64).bool(message.records);
    }
    if (message.sequences !== false) {
      writer.uint32(72).bool(message.sequences);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportSqlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportSqlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.users = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accesses = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.params = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.functions = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.analyzers = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tables = ExportSqlRequest_Tables.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.versions = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.records = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sequences = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportSqlRequest {
    return {
      users: isSet(object.users) ? globalThis.Boolean(object.users) : false,
      accesses: isSet(object.accesses) ? globalThis.Boolean(object.accesses) : false,
      params: isSet(object.params) ? globalThis.Boolean(object.params) : false,
      functions: isSet(object.functions) ? globalThis.Boolean(object.functions) : false,
      analyzers: isSet(object.analyzers) ? globalThis.Boolean(object.analyzers) : false,
      tables: isSet(object.tables) ? ExportSqlRequest_Tables.fromJSON(object.tables) : undefined,
      versions: isSet(object.versions) ? globalThis.Boolean(object.versions) : false,
      records: isSet(object.records) ? globalThis.Boolean(object.records) : false,
      sequences: isSet(object.sequences) ? globalThis.Boolean(object.sequences) : false,
    };
  },

  toJSON(message: ExportSqlRequest): unknown {
    const obj: any = {};
    if (message.users !== false) {
      obj.users = message.users;
    }
    if (message.accesses !== false) {
      obj.accesses = message.accesses;
    }
    if (message.params !== false) {
      obj.params = message.params;
    }
    if (message.functions !== false) {
      obj.functions = message.functions;
    }
    if (message.analyzers !== false) {
      obj.analyzers = message.analyzers;
    }
    if (message.tables !== undefined) {
      obj.tables = ExportSqlRequest_Tables.toJSON(message.tables);
    }
    if (message.versions !== false) {
      obj.versions = message.versions;
    }
    if (message.records !== false) {
      obj.records = message.records;
    }
    if (message.sequences !== false) {
      obj.sequences = message.sequences;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportSqlRequest>, I>>(base?: I): ExportSqlRequest {
    return ExportSqlRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportSqlRequest>, I>>(object: I): ExportSqlRequest {
    const message = createBaseExportSqlRequest();
    message.users = object.users ?? false;
    message.accesses = object.accesses ?? false;
    message.params = object.params ?? false;
    message.functions = object.functions ?? false;
    message.analyzers = object.analyzers ?? false;
    message.tables = (object.tables !== undefined && object.tables !== null)
      ? ExportSqlRequest_Tables.fromPartial(object.tables)
      : undefined;
    message.versions = object.versions ?? false;
    message.records = object.records ?? false;
    message.sequences = object.sequences ?? false;
    return message;
  },
};

function createBaseExportSqlRequest_SelectedTables(): ExportSqlRequest_SelectedTables {
  return { tables: [] };
}

export const ExportSqlRequest_SelectedTables: MessageFns<ExportSqlRequest_SelectedTables> = {
  encode(message: ExportSqlRequest_SelectedTables, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tables) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportSqlRequest_SelectedTables {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportSqlRequest_SelectedTables();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tables.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportSqlRequest_SelectedTables {
    return {
      tables: globalThis.Array.isArray(object?.tables) ? object.tables.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ExportSqlRequest_SelectedTables): unknown {
    const obj: any = {};
    if (message.tables?.length) {
      obj.tables = message.tables;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportSqlRequest_SelectedTables>, I>>(base?: I): ExportSqlRequest_SelectedTables {
    return ExportSqlRequest_SelectedTables.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportSqlRequest_SelectedTables>, I>>(
    object: I,
  ): ExportSqlRequest_SelectedTables {
    const message = createBaseExportSqlRequest_SelectedTables();
    message.tables = object.tables?.map((e) => e) || [];
    return message;
  },
};

function createBaseExportSqlRequest_Tables(): ExportSqlRequest_Tables {
  return { selection: undefined };
}

export const ExportSqlRequest_Tables: MessageFns<ExportSqlRequest_Tables> = {
  encode(message: ExportSqlRequest_Tables, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.selection?.$case) {
      case "all":
        NullValue.encode(message.selection.all, writer.uint32(10).fork()).join();
        break;
      case "none":
        NullValue.encode(message.selection.none, writer.uint32(18).fork()).join();
        break;
      case "selected":
        ExportSqlRequest_SelectedTables.encode(message.selection.selected, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportSqlRequest_Tables {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportSqlRequest_Tables();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.selection = { $case: "all", all: NullValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.selection = { $case: "none", none: NullValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.selection = {
            $case: "selected",
            selected: ExportSqlRequest_SelectedTables.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportSqlRequest_Tables {
    return {
      selection: isSet(object.all)
        ? { $case: "all", all: NullValue.fromJSON(object.all) }
        : isSet(object.none)
        ? { $case: "none", none: NullValue.fromJSON(object.none) }
        : isSet(object.selected)
        ? { $case: "selected", selected: ExportSqlRequest_SelectedTables.fromJSON(object.selected) }
        : undefined,
    };
  },

  toJSON(message: ExportSqlRequest_Tables): unknown {
    const obj: any = {};
    if (message.selection?.$case === "all") {
      obj.all = NullValue.toJSON(message.selection.all);
    } else if (message.selection?.$case === "none") {
      obj.none = NullValue.toJSON(message.selection.none);
    } else if (message.selection?.$case === "selected") {
      obj.selected = ExportSqlRequest_SelectedTables.toJSON(message.selection.selected);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportSqlRequest_Tables>, I>>(base?: I): ExportSqlRequest_Tables {
    return ExportSqlRequest_Tables.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportSqlRequest_Tables>, I>>(object: I): ExportSqlRequest_Tables {
    const message = createBaseExportSqlRequest_Tables();
    switch (object.selection?.$case) {
      case "all": {
        if (object.selection?.all !== undefined && object.selection?.all !== null) {
          message.selection = { $case: "all", all: NullValue.fromPartial(object.selection.all) };
        }
        break;
      }
      case "none": {
        if (object.selection?.none !== undefined && object.selection?.none !== null) {
          message.selection = { $case: "none", none: NullValue.fromPartial(object.selection.none) };
        }
        break;
      }
      case "selected": {
        if (object.selection?.selected !== undefined && object.selection?.selected !== null) {
          message.selection = {
            $case: "selected",
            selected: ExportSqlRequest_SelectedTables.fromPartial(object.selection.selected),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseExportSqlResponse(): ExportSqlResponse {
  return { statement: "" };
}

export const ExportSqlResponse: MessageFns<ExportSqlResponse> = {
  encode(message: ExportSqlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statement !== "") {
      writer.uint32(10).string(message.statement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportSqlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportSqlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statement = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportSqlResponse {
    return { statement: isSet(object.statement) ? globalThis.String(object.statement) : "" };
  },

  toJSON(message: ExportSqlResponse): unknown {
    const obj: any = {};
    if (message.statement !== "") {
      obj.statement = message.statement;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportSqlResponse>, I>>(base?: I): ExportSqlResponse {
    return ExportSqlResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportSqlResponse>, I>>(object: I): ExportSqlResponse {
    const message = createBaseExportSqlResponse();
    message.statement = object.statement ?? "";
    return message;
  },
};

function createBaseExportMlModelRequest(): ExportMlModelRequest {
  return { name: "", version: "" };
}

export const ExportMlModelRequest: MessageFns<ExportMlModelRequest> = {
  encode(message: ExportMlModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportMlModelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportMlModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportMlModelRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: ExportMlModelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportMlModelRequest>, I>>(base?: I): ExportMlModelRequest {
    return ExportMlModelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportMlModelRequest>, I>>(object: I): ExportMlModelRequest {
    const message = createBaseExportMlModelRequest();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseExportMlModelResponse(): ExportMlModelResponse {
  return { model: new Uint8Array(0) };
}

export const ExportMlModelResponse: MessageFns<ExportMlModelResponse> = {
  encode(message: ExportMlModelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model.length !== 0) {
      writer.uint32(10).bytes(message.model);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportMlModelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportMlModelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.model = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportMlModelResponse {
    return { model: isSet(object.model) ? bytesFromBase64(object.model) : new Uint8Array(0) };
  },

  toJSON(message: ExportMlModelResponse): unknown {
    const obj: any = {};
    if (message.model.length !== 0) {
      obj.model = base64FromBytes(message.model);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportMlModelResponse>, I>>(base?: I): ExportMlModelResponse {
    return ExportMlModelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportMlModelResponse>, I>>(object: I): ExportMlModelResponse {
    const message = createBaseExportMlModelResponse();
    message.model = object.model ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubscribeRequest(): SubscribeRequest {
  return { subscribeTo: undefined };
}

export const SubscribeRequest: MessageFns<SubscribeRequest> = {
  encode(message: SubscribeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.subscribeTo?.$case) {
      case "liveQueryId":
        Uuid.encode(message.subscribeTo.liveQueryId, writer.uint32(10).fork()).join();
        break;
      case "query":
        QueryRequest.encode(message.subscribeTo.query, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscribeTo = { $case: "liveQueryId", liveQueryId: Uuid.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscribeTo = { $case: "query", query: QueryRequest.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequest {
    return {
      subscribeTo: isSet(object.liveQueryId)
        ? { $case: "liveQueryId", liveQueryId: Uuid.fromJSON(object.liveQueryId) }
        : isSet(object.query)
        ? { $case: "query", query: QueryRequest.fromJSON(object.query) }
        : undefined,
    };
  },

  toJSON(message: SubscribeRequest): unknown {
    const obj: any = {};
    if (message.subscribeTo?.$case === "liveQueryId") {
      obj.liveQueryId = Uuid.toJSON(message.subscribeTo.liveQueryId);
    } else if (message.subscribeTo?.$case === "query") {
      obj.query = QueryRequest.toJSON(message.subscribeTo.query);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequest>, I>>(base?: I): SubscribeRequest {
    return SubscribeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequest>, I>>(object: I): SubscribeRequest {
    const message = createBaseSubscribeRequest();
    switch (object.subscribeTo?.$case) {
      case "liveQueryId": {
        if (object.subscribeTo?.liveQueryId !== undefined && object.subscribeTo?.liveQueryId !== null) {
          message.subscribeTo = { $case: "liveQueryId", liveQueryId: Uuid.fromPartial(object.subscribeTo.liveQueryId) };
        }
        break;
      }
      case "query": {
        if (object.subscribeTo?.query !== undefined && object.subscribeTo?.query !== null) {
          message.subscribeTo = { $case: "query", query: QueryRequest.fromPartial(object.subscribeTo.query) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSubscribeResponse(): SubscribeResponse {
  return { notification: undefined };
}

export const SubscribeResponse: MessageFns<SubscribeResponse> = {
  encode(message: SubscribeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notification !== undefined) {
      Notification.encode(message.notification, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notification = Notification.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeResponse {
    return { notification: isSet(object.notification) ? Notification.fromJSON(object.notification) : undefined };
  },

  toJSON(message: SubscribeResponse): unknown {
    const obj: any = {};
    if (message.notification !== undefined) {
      obj.notification = Notification.toJSON(message.notification);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeResponse>, I>>(base?: I): SubscribeResponse {
    return SubscribeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeResponse>, I>>(object: I): SubscribeResponse {
    const message = createBaseSubscribeResponse();
    message.notification = (object.notification !== undefined && object.notification !== null)
      ? Notification.fromPartial(object.notification)
      : undefined;
    return message;
  },
};

function createBaseNotification(): Notification {
  return { liveQueryId: undefined, action: 0, recordId: undefined, value: undefined };
}

export const Notification: MessageFns<Notification> = {
  encode(message: Notification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.liveQueryId !== undefined) {
      Uuid.encode(message.liveQueryId, writer.uint32(10).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.recordId !== undefined) {
      RecordId.encode(message.recordId, writer.uint32(26).fork()).join();
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.liveQueryId = Uuid.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.recordId = RecordId.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notification {
    return {
      liveQueryId: isSet(object.liveQueryId) ? Uuid.fromJSON(object.liveQueryId) : undefined,
      action: isSet(object.action) ? actionFromJSON(object.action) : 0,
      recordId: isSet(object.recordId) ? RecordId.fromJSON(object.recordId) : undefined,
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Notification): unknown {
    const obj: any = {};
    if (message.liveQueryId !== undefined) {
      obj.liveQueryId = Uuid.toJSON(message.liveQueryId);
    }
    if (message.action !== 0) {
      obj.action = actionToJSON(message.action);
    }
    if (message.recordId !== undefined) {
      obj.recordId = RecordId.toJSON(message.recordId);
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Notification>, I>>(base?: I): Notification {
    return Notification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Notification>, I>>(object: I): Notification {
    const message = createBaseNotification();
    message.liveQueryId = (object.liveQueryId !== undefined && object.liveQueryId !== null)
      ? Uuid.fromPartial(object.liveQueryId)
      : undefined;
    message.action = object.action ?? 0;
    message.recordId = (object.recordId !== undefined && object.recordId !== null)
      ? RecordId.fromPartial(object.recordId)
      : undefined;
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseQueryRequest(): QueryRequest {
  return { query: "", variables: undefined, txnId: undefined };
}

export const QueryRequest: MessageFns<QueryRequest> = {
  encode(message: QueryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.variables !== undefined) {
      Variables.encode(message.variables, writer.uint32(18).fork()).join();
    }
    if (message.txnId !== undefined) {
      Uuid.encode(message.txnId, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.variables = Variables.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txnId = Uuid.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      variables: isSet(object.variables) ? Variables.fromJSON(object.variables) : undefined,
      txnId: isSet(object.txnId) ? Uuid.fromJSON(object.txnId) : undefined,
    };
  },

  toJSON(message: QueryRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.variables !== undefined) {
      obj.variables = Variables.toJSON(message.variables);
    }
    if (message.txnId !== undefined) {
      obj.txnId = Uuid.toJSON(message.txnId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRequest>, I>>(base?: I): QueryRequest {
    return QueryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRequest>, I>>(object: I): QueryRequest {
    const message = createBaseQueryRequest();
    message.query = object.query ?? "";
    message.variables = (object.variables !== undefined && object.variables !== null)
      ? Variables.fromPartial(object.variables)
      : undefined;
    message.txnId = (object.txnId !== undefined && object.txnId !== null) ? Uuid.fromPartial(object.txnId) : undefined;
    return message;
  },
};

function createBaseQueryResponse(): QueryResponse {
  return { queryIndex: 0, batchIndex: 0n, resultCount: 0, kind: 0, stats: undefined, error: undefined, values: [] };
}

export const QueryResponse: MessageFns<QueryResponse> = {
  encode(message: QueryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryIndex !== 0) {
      writer.uint32(8).uint32(message.queryIndex);
    }
    if (message.batchIndex !== 0n) {
      if (BigInt.asUintN(64, message.batchIndex) !== message.batchIndex) {
        throw new globalThis.Error("value provided for field message.batchIndex of type uint64 too large");
      }
      writer.uint32(16).uint64(message.batchIndex);
    }
    if (message.resultCount !== 0) {
      writer.uint32(24).uint32(message.resultCount);
    }
    if (message.kind !== 0) {
      writer.uint32(32).int32(message.kind);
    }
    if (message.stats !== undefined) {
      QueryStats.encode(message.stats, writer.uint32(42).fork()).join();
    }
    if (message.error !== undefined) {
      QueryError.encode(message.error, writer.uint32(50).fork()).join();
    }
    for (const v of message.values) {
      Value.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.queryIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.batchIndex = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.resultCount = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stats = QueryStats.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = QueryError.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.values.push(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryResponse {
    return {
      queryIndex: isSet(object.queryIndex) ? globalThis.Number(object.queryIndex) : 0,
      batchIndex: isSet(object.batchIndex) ? BigInt(object.batchIndex) : 0n,
      resultCount: isSet(object.resultCount) ? globalThis.Number(object.resultCount) : 0,
      kind: isSet(object.kind) ? queryResponseKindFromJSON(object.kind) : 0,
      stats: isSet(object.stats) ? QueryStats.fromJSON(object.stats) : undefined,
      error: isSet(object.error) ? QueryError.fromJSON(object.error) : undefined,
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Value.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryResponse): unknown {
    const obj: any = {};
    if (message.queryIndex !== 0) {
      obj.queryIndex = Math.round(message.queryIndex);
    }
    if (message.batchIndex !== 0n) {
      obj.batchIndex = message.batchIndex.toString();
    }
    if (message.resultCount !== 0) {
      obj.resultCount = Math.round(message.resultCount);
    }
    if (message.kind !== 0) {
      obj.kind = queryResponseKindToJSON(message.kind);
    }
    if (message.stats !== undefined) {
      obj.stats = QueryStats.toJSON(message.stats);
    }
    if (message.error !== undefined) {
      obj.error = QueryError.toJSON(message.error);
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryResponse>, I>>(base?: I): QueryResponse {
    return QueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryResponse>, I>>(object: I): QueryResponse {
    const message = createBaseQueryResponse();
    message.queryIndex = object.queryIndex ?? 0;
    message.batchIndex = object.batchIndex ?? 0n;
    message.resultCount = object.resultCount ?? 0;
    message.kind = object.kind ?? 0;
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? QueryStats.fromPartial(object.stats)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? QueryError.fromPartial(object.error)
      : undefined;
    message.values = object.values?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryStats(): QueryStats {
  return { recordsReturned: 0n, bytesReturned: 0n, recordsScanned: 0n, bytesScanned: 0n, executionDuration: undefined };
}

export const QueryStats: MessageFns<QueryStats> = {
  encode(message: QueryStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recordsReturned !== 0n) {
      if (BigInt.asIntN(64, message.recordsReturned) !== message.recordsReturned) {
        throw new globalThis.Error("value provided for field message.recordsReturned of type int64 too large");
      }
      writer.uint32(8).int64(message.recordsReturned);
    }
    if (message.bytesReturned !== 0n) {
      if (BigInt.asIntN(64, message.bytesReturned) !== message.bytesReturned) {
        throw new globalThis.Error("value provided for field message.bytesReturned of type int64 too large");
      }
      writer.uint32(16).int64(message.bytesReturned);
    }
    if (message.recordsScanned !== 0n) {
      if (BigInt.asIntN(64, message.recordsScanned) !== message.recordsScanned) {
        throw new globalThis.Error("value provided for field message.recordsScanned of type int64 too large");
      }
      writer.uint32(24).int64(message.recordsScanned);
    }
    if (message.bytesScanned !== 0n) {
      if (BigInt.asIntN(64, message.bytesScanned) !== message.bytesScanned) {
        throw new globalThis.Error("value provided for field message.bytesScanned of type int64 too large");
      }
      writer.uint32(32).int64(message.bytesScanned);
    }
    if (message.executionDuration !== undefined) {
      Duration.encode(message.executionDuration, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.recordsReturned = reader.int64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bytesReturned = reader.int64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.recordsScanned = reader.int64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bytesScanned = reader.int64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.executionDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStats {
    return {
      recordsReturned: isSet(object.recordsReturned) ? BigInt(object.recordsReturned) : 0n,
      bytesReturned: isSet(object.bytesReturned) ? BigInt(object.bytesReturned) : 0n,
      recordsScanned: isSet(object.recordsScanned) ? BigInt(object.recordsScanned) : 0n,
      bytesScanned: isSet(object.bytesScanned) ? BigInt(object.bytesScanned) : 0n,
      executionDuration: isSet(object.executionDuration) ? Duration.fromJSON(object.executionDuration) : undefined,
    };
  },

  toJSON(message: QueryStats): unknown {
    const obj: any = {};
    if (message.recordsReturned !== 0n) {
      obj.recordsReturned = message.recordsReturned.toString();
    }
    if (message.bytesReturned !== 0n) {
      obj.bytesReturned = message.bytesReturned.toString();
    }
    if (message.recordsScanned !== 0n) {
      obj.recordsScanned = message.recordsScanned.toString();
    }
    if (message.bytesScanned !== 0n) {
      obj.bytesScanned = message.bytesScanned.toString();
    }
    if (message.executionDuration !== undefined) {
      obj.executionDuration = Duration.toJSON(message.executionDuration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStats>, I>>(base?: I): QueryStats {
    return QueryStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStats>, I>>(object: I): QueryStats {
    const message = createBaseQueryStats();
    message.recordsReturned = object.recordsReturned ?? 0n;
    message.bytesReturned = object.bytesReturned ?? 0n;
    message.recordsScanned = object.recordsScanned ?? 0n;
    message.bytesScanned = object.bytesScanned ?? 0n;
    message.executionDuration = (object.executionDuration !== undefined && object.executionDuration !== null)
      ? Duration.fromPartial(object.executionDuration)
      : undefined;
    return message;
  },
};

function createBaseQueryError(): QueryError {
  return { code: 0n, message: "" };
}

export const QueryError: MessageFns<QueryError> = {
  encode(message: QueryError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0n) {
      if (BigInt.asIntN(64, message.code) !== message.code) {
        throw new globalThis.Error("value provided for field message.code of type int64 too large");
      }
      writer.uint32(8).int64(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryError {
    return {
      code: isSet(object.code) ? BigInt(object.code) : 0n,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: QueryError): unknown {
    const obj: any = {};
    if (message.code !== 0n) {
      obj.code = message.code.toString();
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryError>, I>>(base?: I): QueryError {
    return QueryError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryError>, I>>(object: I): QueryError {
    const message = createBaseQueryError();
    message.code = object.code ?? 0n;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseRootUserCredentials(): RootUserCredentials {
  return { username: "", password: "" };
}

export const RootUserCredentials: MessageFns<RootUserCredentials> = {
  encode(message: RootUserCredentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RootUserCredentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRootUserCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RootUserCredentials {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: RootUserCredentials): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RootUserCredentials>, I>>(base?: I): RootUserCredentials {
    return RootUserCredentials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RootUserCredentials>, I>>(object: I): RootUserCredentials {
    const message = createBaseRootUserCredentials();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseNamespaceAccessCredentials(): NamespaceAccessCredentials {
  return { namespace: "", access: "", key: "" };
}

export const NamespaceAccessCredentials: MessageFns<NamespaceAccessCredentials> = {
  encode(message: NamespaceAccessCredentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.access !== "") {
      writer.uint32(18).string(message.access);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamespaceAccessCredentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamespaceAccessCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.access = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamespaceAccessCredentials {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      access: isSet(object.access) ? globalThis.String(object.access) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: NamespaceAccessCredentials): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.access !== "") {
      obj.access = message.access;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamespaceAccessCredentials>, I>>(base?: I): NamespaceAccessCredentials {
    return NamespaceAccessCredentials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamespaceAccessCredentials>, I>>(object: I): NamespaceAccessCredentials {
    const message = createBaseNamespaceAccessCredentials();
    message.namespace = object.namespace ?? "";
    message.access = object.access ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseDatabaseAccessCredentials(): DatabaseAccessCredentials {
  return { namespace: "", database: "", access: "", key: "", refresh: "" };
}

export const DatabaseAccessCredentials: MessageFns<DatabaseAccessCredentials> = {
  encode(message: DatabaseAccessCredentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.database !== "") {
      writer.uint32(18).string(message.database);
    }
    if (message.access !== "") {
      writer.uint32(26).string(message.access);
    }
    if (message.key !== "") {
      writer.uint32(34).string(message.key);
    }
    if (message.refresh !== "") {
      writer.uint32(42).string(message.refresh);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseAccessCredentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseAccessCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.database = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.access = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refresh = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseAccessCredentials {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      access: isSet(object.access) ? globalThis.String(object.access) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      refresh: isSet(object.refresh) ? globalThis.String(object.refresh) : "",
    };
  },

  toJSON(message: DatabaseAccessCredentials): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.access !== "") {
      obj.access = message.access;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.refresh !== "") {
      obj.refresh = message.refresh;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatabaseAccessCredentials>, I>>(base?: I): DatabaseAccessCredentials {
    return DatabaseAccessCredentials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatabaseAccessCredentials>, I>>(object: I): DatabaseAccessCredentials {
    const message = createBaseDatabaseAccessCredentials();
    message.namespace = object.namespace ?? "";
    message.database = object.database ?? "";
    message.access = object.access ?? "";
    message.key = object.key ?? "";
    message.refresh = object.refresh ?? "";
    return message;
  },
};

function createBaseNamespaceUserCredentials(): NamespaceUserCredentials {
  return { namespace: "", username: "", password: "" };
}

export const NamespaceUserCredentials: MessageFns<NamespaceUserCredentials> = {
  encode(message: NamespaceUserCredentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamespaceUserCredentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamespaceUserCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamespaceUserCredentials {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: NamespaceUserCredentials): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamespaceUserCredentials>, I>>(base?: I): NamespaceUserCredentials {
    return NamespaceUserCredentials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamespaceUserCredentials>, I>>(object: I): NamespaceUserCredentials {
    const message = createBaseNamespaceUserCredentials();
    message.namespace = object.namespace ?? "";
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseDatabaseUserCredentials(): DatabaseUserCredentials {
  return { namespace: "", database: "", username: "", password: "" };
}

export const DatabaseUserCredentials: MessageFns<DatabaseUserCredentials> = {
  encode(message: DatabaseUserCredentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.database !== "") {
      writer.uint32(18).string(message.database);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseUserCredentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseUserCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.database = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseUserCredentials {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: DatabaseUserCredentials): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatabaseUserCredentials>, I>>(base?: I): DatabaseUserCredentials {
    return DatabaseUserCredentials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatabaseUserCredentials>, I>>(object: I): DatabaseUserCredentials {
    const message = createBaseDatabaseUserCredentials();
    message.namespace = object.namespace ?? "";
    message.database = object.database ?? "";
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseAccessToken(): AccessToken {
  return { token: "" };
}

export const AccessToken: MessageFns<AccessToken> = {
  encode(message: AccessToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessToken {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: AccessToken): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessToken>, I>>(base?: I): AccessToken {
    return AccessToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessToken>, I>>(object: I): AccessToken {
    const message = createBaseAccessToken();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseAccessMethod(): AccessMethod {
  return { method: undefined };
}

export const AccessMethod: MessageFns<AccessMethod> = {
  encode(message: AccessMethod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.method?.$case) {
      case "root":
        RootUserCredentials.encode(message.method.root, writer.uint32(10).fork()).join();
        break;
      case "namespace":
        NamespaceAccessCredentials.encode(message.method.namespace, writer.uint32(18).fork()).join();
        break;
      case "database":
        DatabaseAccessCredentials.encode(message.method.database, writer.uint32(26).fork()).join();
        break;
      case "namespaceUser":
        NamespaceUserCredentials.encode(message.method.namespaceUser, writer.uint32(34).fork()).join();
        break;
      case "databaseUser":
        DatabaseUserCredentials.encode(message.method.databaseUser, writer.uint32(42).fork()).join();
        break;
      case "accessToken":
        AccessToken.encode(message.method.accessToken, writer.uint32(50).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessMethod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.method = { $case: "root", root: RootUserCredentials.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.method = {
            $case: "namespace",
            namespace: NamespaceAccessCredentials.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.method = { $case: "database", database: DatabaseAccessCredentials.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.method = {
            $case: "namespaceUser",
            namespaceUser: NamespaceUserCredentials.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.method = {
            $case: "databaseUser",
            databaseUser: DatabaseUserCredentials.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.method = { $case: "accessToken", accessToken: AccessToken.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessMethod {
    return {
      method: isSet(object.root)
        ? { $case: "root", root: RootUserCredentials.fromJSON(object.root) }
        : isSet(object.namespace)
        ? { $case: "namespace", namespace: NamespaceAccessCredentials.fromJSON(object.namespace) }
        : isSet(object.database)
        ? { $case: "database", database: DatabaseAccessCredentials.fromJSON(object.database) }
        : isSet(object.namespaceUser)
        ? { $case: "namespaceUser", namespaceUser: NamespaceUserCredentials.fromJSON(object.namespaceUser) }
        : isSet(object.databaseUser)
        ? { $case: "databaseUser", databaseUser: DatabaseUserCredentials.fromJSON(object.databaseUser) }
        : isSet(object.accessToken)
        ? { $case: "accessToken", accessToken: AccessToken.fromJSON(object.accessToken) }
        : undefined,
    };
  },

  toJSON(message: AccessMethod): unknown {
    const obj: any = {};
    if (message.method?.$case === "root") {
      obj.root = RootUserCredentials.toJSON(message.method.root);
    } else if (message.method?.$case === "namespace") {
      obj.namespace = NamespaceAccessCredentials.toJSON(message.method.namespace);
    } else if (message.method?.$case === "database") {
      obj.database = DatabaseAccessCredentials.toJSON(message.method.database);
    } else if (message.method?.$case === "namespaceUser") {
      obj.namespaceUser = NamespaceUserCredentials.toJSON(message.method.namespaceUser);
    } else if (message.method?.$case === "databaseUser") {
      obj.databaseUser = DatabaseUserCredentials.toJSON(message.method.databaseUser);
    } else if (message.method?.$case === "accessToken") {
      obj.accessToken = AccessToken.toJSON(message.method.accessToken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessMethod>, I>>(base?: I): AccessMethod {
    return AccessMethod.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessMethod>, I>>(object: I): AccessMethod {
    const message = createBaseAccessMethod();
    switch (object.method?.$case) {
      case "root": {
        if (object.method?.root !== undefined && object.method?.root !== null) {
          message.method = { $case: "root", root: RootUserCredentials.fromPartial(object.method.root) };
        }
        break;
      }
      case "namespace": {
        if (object.method?.namespace !== undefined && object.method?.namespace !== null) {
          message.method = {
            $case: "namespace",
            namespace: NamespaceAccessCredentials.fromPartial(object.method.namespace),
          };
        }
        break;
      }
      case "database": {
        if (object.method?.database !== undefined && object.method?.database !== null) {
          message.method = {
            $case: "database",
            database: DatabaseAccessCredentials.fromPartial(object.method.database),
          };
        }
        break;
      }
      case "namespaceUser": {
        if (object.method?.namespaceUser !== undefined && object.method?.namespaceUser !== null) {
          message.method = {
            $case: "namespaceUser",
            namespaceUser: NamespaceUserCredentials.fromPartial(object.method.namespaceUser),
          };
        }
        break;
      }
      case "databaseUser": {
        if (object.method?.databaseUser !== undefined && object.method?.databaseUser !== null) {
          message.method = {
            $case: "databaseUser",
            databaseUser: DatabaseUserCredentials.fromPartial(object.method.databaseUser),
          };
        }
        break;
      }
      case "accessToken": {
        if (object.method?.accessToken !== undefined && object.method?.accessToken !== null) {
          message.method = { $case: "accessToken", accessToken: AccessToken.fromPartial(object.method.accessToken) };
        }
        break;
      }
    }
    return message;
  },
};

/** SurrealDB service. */
export interface SurrealDBService {
  /** Check the health of the database. */
  Health(request: HealthRequest): Promise<HealthResponse>;
  /** Get the version of the database. */
  Version(request: VersionRequest): Promise<VersionResponse>;
  /** Sign up a new user. */
  Signup(request: SignupRequest): Promise<SignupResponse>;
  /** Sign in a user. */
  Signin(request: SigninRequest): Promise<SigninResponse>;
  /** Authenticate a user with a token. */
  Authenticate(request: AuthenticateRequest): Promise<AuthenticateResponse>;
  /** Use a namespace and database. */
  Use(request: UseRequest): Promise<UseResponse>;
  /** Set a global variable for the current session. */
  Set(request: SetRequest): Promise<SetResponse>;
  /** Unset a global variable for the current session. */
  Unset(request: UnsetRequest): Promise<UnsetResponse>;
  /** Clear the current IAM session info. */
  Invalidate(request: InvalidateRequest): Promise<InvalidateResponse>;
  /** Clear the current IAM session info and reset all global variables for the current session (ns, db, vars). */
  Reset(request: ResetRequest): Promise<ResetResponse>;
  /**
   * Import data into the database.
   * All statements are executed in the same transaction.
   */
  ImportSql(request: Observable<ImportSqlRequest>): Promise<ImportSqlResponse>;
  /** Export data from the database. */
  ExportSql(request: ExportSqlRequest): Observable<ExportSqlResponse>;
  /** Export the ML model. */
  ExportMlModel(request: ExportMlModelRequest): Observable<ExportMlModelResponse>;
  /** Query the database and get a stream of values. */
  Query(request: QueryRequest): Observable<QueryResponse>;
  /** Issue a live query and get a stream of notifications. */
  Subscribe(request: SubscribeRequest): Observable<SubscribeResponse>;
}

export const SurrealDBServiceServiceName = "surrealdb.protocol.rpc.v1.SurrealDBService";
export class SurrealDBServiceClientImpl implements SurrealDBService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SurrealDBServiceServiceName;
    this.rpc = rpc;
    this.Health = this.Health.bind(this);
    this.Version = this.Version.bind(this);
    this.Signup = this.Signup.bind(this);
    this.Signin = this.Signin.bind(this);
    this.Authenticate = this.Authenticate.bind(this);
    this.Use = this.Use.bind(this);
    this.Set = this.Set.bind(this);
    this.Unset = this.Unset.bind(this);
    this.Invalidate = this.Invalidate.bind(this);
    this.Reset = this.Reset.bind(this);
    this.ImportSql = this.ImportSql.bind(this);
    this.ExportSql = this.ExportSql.bind(this);
    this.ExportMlModel = this.ExportMlModel.bind(this);
    this.Query = this.Query.bind(this);
    this.Subscribe = this.Subscribe.bind(this);
  }
  Health(request: HealthRequest): Promise<HealthResponse> {
    const data = HealthRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Health", data);
    return promise.then((data) => HealthResponse.decode(new BinaryReader(data)));
  }

  Version(request: VersionRequest): Promise<VersionResponse> {
    const data = VersionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Version", data);
    return promise.then((data) => VersionResponse.decode(new BinaryReader(data)));
  }

  Signup(request: SignupRequest): Promise<SignupResponse> {
    const data = SignupRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Signup", data);
    return promise.then((data) => SignupResponse.decode(new BinaryReader(data)));
  }

  Signin(request: SigninRequest): Promise<SigninResponse> {
    const data = SigninRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Signin", data);
    return promise.then((data) => SigninResponse.decode(new BinaryReader(data)));
  }

  Authenticate(request: AuthenticateRequest): Promise<AuthenticateResponse> {
    const data = AuthenticateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Authenticate", data);
    return promise.then((data) => AuthenticateResponse.decode(new BinaryReader(data)));
  }

  Use(request: UseRequest): Promise<UseResponse> {
    const data = UseRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Use", data);
    return promise.then((data) => UseResponse.decode(new BinaryReader(data)));
  }

  Set(request: SetRequest): Promise<SetResponse> {
    const data = SetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Set", data);
    return promise.then((data) => SetResponse.decode(new BinaryReader(data)));
  }

  Unset(request: UnsetRequest): Promise<UnsetResponse> {
    const data = UnsetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Unset", data);
    return promise.then((data) => UnsetResponse.decode(new BinaryReader(data)));
  }

  Invalidate(request: InvalidateRequest): Promise<InvalidateResponse> {
    const data = InvalidateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Invalidate", data);
    return promise.then((data) => InvalidateResponse.decode(new BinaryReader(data)));
  }

  Reset(request: ResetRequest): Promise<ResetResponse> {
    const data = ResetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Reset", data);
    return promise.then((data) => ResetResponse.decode(new BinaryReader(data)));
  }

  ImportSql(request: Observable<ImportSqlRequest>): Promise<ImportSqlResponse> {
    const data = request.pipe(map((request) => ImportSqlRequest.encode(request).finish()));
    const promise = this.rpc.clientStreamingRequest(this.service, "ImportSql", data);
    return promise.then((data) => ImportSqlResponse.decode(new BinaryReader(data)));
  }

  ExportSql(request: ExportSqlRequest): Observable<ExportSqlResponse> {
    const data = ExportSqlRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "ExportSql", data);
    return result.pipe(map((data) => ExportSqlResponse.decode(new BinaryReader(data))));
  }

  ExportMlModel(request: ExportMlModelRequest): Observable<ExportMlModelResponse> {
    const data = ExportMlModelRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "ExportMlModel", data);
    return result.pipe(map((data) => ExportMlModelResponse.decode(new BinaryReader(data))));
  }

  Query(request: QueryRequest): Observable<QueryResponse> {
    const data = QueryRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "Query", data);
    return result.pipe(map((data) => QueryResponse.decode(new BinaryReader(data))));
  }

  Subscribe(request: SubscribeRequest): Observable<SubscribeResponse> {
    const data = SubscribeRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "Subscribe", data);
    return result.pipe(map((data) => SubscribeResponse.decode(new BinaryReader(data))));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
