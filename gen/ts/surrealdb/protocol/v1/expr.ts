// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: surrealdb/protocol/v1/expr.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { NullValue, Value } from "./value";

export const protobufPackage = "surrealdb.protocol.v1";

/**
 * Supported operators.
 *
 * Note: This is a subset of the operators supported by the SurrealQL parser. This only includes operators that do not take arguments.
 */
export enum Operator {
  UNSPECIFIED = 0,
  /** NEG - `-` */
  NEG = 1,
  /** NOT - `!` */
  NOT = 2,
  /** OR - `||` */
  OR = 3,
  /** AND - `&&` */
  AND = 4,
  /** TCO - `?:` */
  TCO = 5,
  /** NCO - `??` */
  NCO = 6,
  /** ADD - `+` */
  ADD = 7,
  /** SUB - `-` */
  SUB = 8,
  /** MUL - `*` */
  MUL = 9,
  /** DIV - `/` */
  DIV = 10,
  /** REM - `%` */
  REM = 11,
  /** POW - `**` */
  POW = 12,
  /** INC - `+=` */
  INC = 13,
  /** DEC - `-=` */
  DEC = 14,
  /** EXT - `..` */
  EXT = 15,
  /** EQUAL - `=` */
  EQUAL = 16,
  /** EXACT - `==` */
  EXACT = 17,
  /** NOT_EQUAL - `!=` */
  NOT_EQUAL = 18,
  /** ALL_EQUAL - `*=` */
  ALL_EQUAL = 19,
  /** ANY_EQUAL - `?=` */
  ANY_EQUAL = 20,
  /** LIKE - `~` */
  LIKE = 21,
  /** NOT_LIKE - `!~` */
  NOT_LIKE = 22,
  /** ALL_LIKE - `*~` */
  ALL_LIKE = 23,
  /** ANY_LIKE - `?~` */
  ANY_LIKE = 24,
  /** LESS_THAN - `<` */
  LESS_THAN = 25,
  /** LESS_THAN_OR_EQUAL - `<=` */
  LESS_THAN_OR_EQUAL = 26,
  /** GREATER_THAN - `>` */
  GREATER_THAN = 27,
  /** GREATER_THAN_OR_EQUAL - `>=` */
  GREATER_THAN_OR_EQUAL = 28,
  /** CONTAIN - `∋` */
  CONTAIN = 29,
  /** NOT_CONTAIN - `∌` */
  NOT_CONTAIN = 30,
  /** CONTAIN_ALL - `⊇` */
  CONTAIN_ALL = 31,
  /** CONTAIN_ANY - `⊃` */
  CONTAIN_ANY = 32,
  /** CONTAIN_NONE - `⊅` */
  CONTAIN_NONE = 33,
  /** INSIDE - `∈` */
  INSIDE = 34,
  /** NOT_INSIDE - `∉` */
  NOT_INSIDE = 35,
  /** ALL_INSIDE - `⊆` */
  ALL_INSIDE = 36,
  /** ANY_INSIDE - `⊂` */
  ANY_INSIDE = 37,
  /** NONE_INSIDE - `⊄` */
  NONE_INSIDE = 38,
  /** OUTSIDE - `OUTSIDE` */
  OUTSIDE = 39,
  /** INTERSECTS - `INTERSECTS` */
  INTERSECTS = 40,
  UNRECOGNIZED = -1,
}

export function operatorFromJSON(object: any): Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return Operator.UNSPECIFIED;
    case 1:
    case "OPERATOR_NEG":
      return Operator.NEG;
    case 2:
    case "OPERATOR_NOT":
      return Operator.NOT;
    case 3:
    case "OPERATOR_OR":
      return Operator.OR;
    case 4:
    case "OPERATOR_AND":
      return Operator.AND;
    case 5:
    case "OPERATOR_TCO":
      return Operator.TCO;
    case 6:
    case "OPERATOR_NCO":
      return Operator.NCO;
    case 7:
    case "OPERATOR_ADD":
      return Operator.ADD;
    case 8:
    case "OPERATOR_SUB":
      return Operator.SUB;
    case 9:
    case "OPERATOR_MUL":
      return Operator.MUL;
    case 10:
    case "OPERATOR_DIV":
      return Operator.DIV;
    case 11:
    case "OPERATOR_REM":
      return Operator.REM;
    case 12:
    case "OPERATOR_POW":
      return Operator.POW;
    case 13:
    case "OPERATOR_INC":
      return Operator.INC;
    case 14:
    case "OPERATOR_DEC":
      return Operator.DEC;
    case 15:
    case "OPERATOR_EXT":
      return Operator.EXT;
    case 16:
    case "OPERATOR_EQUAL":
      return Operator.EQUAL;
    case 17:
    case "OPERATOR_EXACT":
      return Operator.EXACT;
    case 18:
    case "OPERATOR_NOT_EQUAL":
      return Operator.NOT_EQUAL;
    case 19:
    case "OPERATOR_ALL_EQUAL":
      return Operator.ALL_EQUAL;
    case 20:
    case "OPERATOR_ANY_EQUAL":
      return Operator.ANY_EQUAL;
    case 21:
    case "OPERATOR_LIKE":
      return Operator.LIKE;
    case 22:
    case "OPERATOR_NOT_LIKE":
      return Operator.NOT_LIKE;
    case 23:
    case "OPERATOR_ALL_LIKE":
      return Operator.ALL_LIKE;
    case 24:
    case "OPERATOR_ANY_LIKE":
      return Operator.ANY_LIKE;
    case 25:
    case "OPERATOR_LESS_THAN":
      return Operator.LESS_THAN;
    case 26:
    case "OPERATOR_LESS_THAN_OR_EQUAL":
      return Operator.LESS_THAN_OR_EQUAL;
    case 27:
    case "OPERATOR_GREATER_THAN":
      return Operator.GREATER_THAN;
    case 28:
    case "OPERATOR_GREATER_THAN_OR_EQUAL":
      return Operator.GREATER_THAN_OR_EQUAL;
    case 29:
    case "OPERATOR_CONTAIN":
      return Operator.CONTAIN;
    case 30:
    case "OPERATOR_NOT_CONTAIN":
      return Operator.NOT_CONTAIN;
    case 31:
    case "OPERATOR_CONTAIN_ALL":
      return Operator.CONTAIN_ALL;
    case 32:
    case "OPERATOR_CONTAIN_ANY":
      return Operator.CONTAIN_ANY;
    case 33:
    case "OPERATOR_CONTAIN_NONE":
      return Operator.CONTAIN_NONE;
    case 34:
    case "OPERATOR_INSIDE":
      return Operator.INSIDE;
    case 35:
    case "OPERATOR_NOT_INSIDE":
      return Operator.NOT_INSIDE;
    case 36:
    case "OPERATOR_ALL_INSIDE":
      return Operator.ALL_INSIDE;
    case 37:
    case "OPERATOR_ANY_INSIDE":
      return Operator.ANY_INSIDE;
    case 38:
    case "OPERATOR_NONE_INSIDE":
      return Operator.NONE_INSIDE;
    case 39:
    case "OPERATOR_OUTSIDE":
      return Operator.OUTSIDE;
    case 40:
    case "OPERATOR_INTERSECTS":
      return Operator.INTERSECTS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operator.UNRECOGNIZED;
  }
}

export function operatorToJSON(object: Operator): string {
  switch (object) {
    case Operator.UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case Operator.NEG:
      return "OPERATOR_NEG";
    case Operator.NOT:
      return "OPERATOR_NOT";
    case Operator.OR:
      return "OPERATOR_OR";
    case Operator.AND:
      return "OPERATOR_AND";
    case Operator.TCO:
      return "OPERATOR_TCO";
    case Operator.NCO:
      return "OPERATOR_NCO";
    case Operator.ADD:
      return "OPERATOR_ADD";
    case Operator.SUB:
      return "OPERATOR_SUB";
    case Operator.MUL:
      return "OPERATOR_MUL";
    case Operator.DIV:
      return "OPERATOR_DIV";
    case Operator.REM:
      return "OPERATOR_REM";
    case Operator.POW:
      return "OPERATOR_POW";
    case Operator.INC:
      return "OPERATOR_INC";
    case Operator.DEC:
      return "OPERATOR_DEC";
    case Operator.EXT:
      return "OPERATOR_EXT";
    case Operator.EQUAL:
      return "OPERATOR_EQUAL";
    case Operator.EXACT:
      return "OPERATOR_EXACT";
    case Operator.NOT_EQUAL:
      return "OPERATOR_NOT_EQUAL";
    case Operator.ALL_EQUAL:
      return "OPERATOR_ALL_EQUAL";
    case Operator.ANY_EQUAL:
      return "OPERATOR_ANY_EQUAL";
    case Operator.LIKE:
      return "OPERATOR_LIKE";
    case Operator.NOT_LIKE:
      return "OPERATOR_NOT_LIKE";
    case Operator.ALL_LIKE:
      return "OPERATOR_ALL_LIKE";
    case Operator.ANY_LIKE:
      return "OPERATOR_ANY_LIKE";
    case Operator.LESS_THAN:
      return "OPERATOR_LESS_THAN";
    case Operator.LESS_THAN_OR_EQUAL:
      return "OPERATOR_LESS_THAN_OR_EQUAL";
    case Operator.GREATER_THAN:
      return "OPERATOR_GREATER_THAN";
    case Operator.GREATER_THAN_OR_EQUAL:
      return "OPERATOR_GREATER_THAN_OR_EQUAL";
    case Operator.CONTAIN:
      return "OPERATOR_CONTAIN";
    case Operator.NOT_CONTAIN:
      return "OPERATOR_NOT_CONTAIN";
    case Operator.CONTAIN_ALL:
      return "OPERATOR_CONTAIN_ALL";
    case Operator.CONTAIN_ANY:
      return "OPERATOR_CONTAIN_ANY";
    case Operator.CONTAIN_NONE:
      return "OPERATOR_CONTAIN_NONE";
    case Operator.INSIDE:
      return "OPERATOR_INSIDE";
    case Operator.NOT_INSIDE:
      return "OPERATOR_NOT_INSIDE";
    case Operator.ALL_INSIDE:
      return "OPERATOR_ALL_INSIDE";
    case Operator.ANY_INSIDE:
      return "OPERATOR_ANY_INSIDE";
    case Operator.NONE_INSIDE:
      return "OPERATOR_NONE_INSIDE";
    case Operator.OUTSIDE:
      return "OPERATOR_OUTSIDE";
    case Operator.INTERSECTS:
      return "OPERATOR_INTERSECTS";
    case Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Identifier. */
export interface Ident {
  value: string;
}

/** Fields selection. */
export interface Fields {
  /** Whether this is a single VALUE clause. */
  single: boolean;
  /** Field selection. */
  fields: Fields_Field[];
}

/** Single field. */
export interface Fields_SingleField {
  /** Expression. */
  expr:
    | Value
    | undefined;
  /** Alias. */
  alias: Idiom | undefined;
}

/** Field selection. */
export interface Fields_Field {
  field?:
    | //
    /** All fields. */
    { $case: "all"; all: NullValue }
    | //
    /** Single field. */
    { $case: "single"; single: Fields_SingleField }
    | undefined;
}

/** Idiom which represents a field expression (e.g. `a.b.c` or `a.b[0]`). */
export interface Idiom {
  value: string;
}

/** Data expression. */
export interface Data {
  data?:
    | { $case: "empty"; empty: NullValue }
    | { $case: "set"; set: Data_SetMultiExpr }
    | { $case: "unset"; unset: Data_UnsetMultiExpr }
    | { $case: "patch"; patch: Value }
    | { $case: "merge"; merge: Value }
    | { $case: "replace"; replace: Value }
    | { $case: "content"; content: Value }
    | { $case: "value"; value: Value }
    | { $case: "values"; values: Data_ValuesMultiExpr }
    | { $case: "update"; update: Data_SetMultiExpr }
    | undefined;
}

/** Set expression (e.g. `a = 1` or `a.b += 1`). */
export interface Data_SetExpr {
  /** Idiom. */
  idiom:
    | Idiom
    | undefined;
  /** Operator. */
  operator: Operator;
  /** Value. */
  value: Value | undefined;
}

/** Set multiple expressions. */
export interface Data_SetMultiExpr {
  items: Data_SetExpr[];
}

/** Unset multiple expressions. */
export interface Data_UnsetMultiExpr {
  items: Idiom[];
}

/** Idiom and value pair. */
export interface Data_IdiomValuePair {
  idiom: Idiom | undefined;
  value: Value | undefined;
}

/** Values expression. */
export interface Data_ValuesExpr {
  items: Data_IdiomValuePair[];
}

/** Values multiple expressions. */
export interface Data_ValuesMultiExpr {
  items: Data_ValuesExpr[];
}

/** Fetchs expression. */
export interface Fetchs {
  items: Value[];
}

function createBaseIdent(): Ident {
  return { value: "" };
}

export const Ident: MessageFns<Ident> = {
  encode(message: Ident, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ident {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ident {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: Ident): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ident>, I>>(base?: I): Ident {
    return Ident.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ident>, I>>(object: I): Ident {
    const message = createBaseIdent();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFields(): Fields {
  return { single: false, fields: [] };
}

export const Fields: MessageFns<Fields> = {
  encode(message: Fields, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.single !== false) {
      writer.uint32(8).bool(message.single);
    }
    for (const v of message.fields) {
      Fields_Field.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fields {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.single = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fields.push(Fields_Field.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fields {
    return {
      single: isSet(object.single) ? globalThis.Boolean(object.single) : false,
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => Fields_Field.fromJSON(e)) : [],
    };
  },

  toJSON(message: Fields): unknown {
    const obj: any = {};
    if (message.single !== false) {
      obj.single = message.single;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => Fields_Field.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fields>, I>>(base?: I): Fields {
    return Fields.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fields>, I>>(object: I): Fields {
    const message = createBaseFields();
    message.single = object.single ?? false;
    message.fields = object.fields?.map((e) => Fields_Field.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFields_SingleField(): Fields_SingleField {
  return { expr: undefined, alias: undefined };
}

export const Fields_SingleField: MessageFns<Fields_SingleField> = {
  encode(message: Fields_SingleField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      Value.encode(message.expr, writer.uint32(10).fork()).join();
    }
    if (message.alias !== undefined) {
      Idiom.encode(message.alias, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fields_SingleField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFields_SingleField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = Value.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.alias = Idiom.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fields_SingleField {
    return {
      expr: isSet(object.expr) ? Value.fromJSON(object.expr) : undefined,
      alias: isSet(object.alias) ? Idiom.fromJSON(object.alias) : undefined,
    };
  },

  toJSON(message: Fields_SingleField): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = Value.toJSON(message.expr);
    }
    if (message.alias !== undefined) {
      obj.alias = Idiom.toJSON(message.alias);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fields_SingleField>, I>>(base?: I): Fields_SingleField {
    return Fields_SingleField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fields_SingleField>, I>>(object: I): Fields_SingleField {
    const message = createBaseFields_SingleField();
    message.expr = (object.expr !== undefined && object.expr !== null) ? Value.fromPartial(object.expr) : undefined;
    message.alias = (object.alias !== undefined && object.alias !== null) ? Idiom.fromPartial(object.alias) : undefined;
    return message;
  },
};

function createBaseFields_Field(): Fields_Field {
  return { field: undefined };
}

export const Fields_Field: MessageFns<Fields_Field> = {
  encode(message: Fields_Field, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.field?.$case) {
      case "all":
        NullValue.encode(message.field.all, writer.uint32(10).fork()).join();
        break;
      case "single":
        Fields_SingleField.encode(message.field.single, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fields_Field {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFields_Field();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = { $case: "all", all: NullValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.field = { $case: "single", single: Fields_SingleField.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fields_Field {
    return {
      field: isSet(object.all)
        ? { $case: "all", all: NullValue.fromJSON(object.all) }
        : isSet(object.single)
        ? { $case: "single", single: Fields_SingleField.fromJSON(object.single) }
        : undefined,
    };
  },

  toJSON(message: Fields_Field): unknown {
    const obj: any = {};
    if (message.field?.$case === "all") {
      obj.all = NullValue.toJSON(message.field.all);
    } else if (message.field?.$case === "single") {
      obj.single = Fields_SingleField.toJSON(message.field.single);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fields_Field>, I>>(base?: I): Fields_Field {
    return Fields_Field.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fields_Field>, I>>(object: I): Fields_Field {
    const message = createBaseFields_Field();
    switch (object.field?.$case) {
      case "all": {
        if (object.field?.all !== undefined && object.field?.all !== null) {
          message.field = { $case: "all", all: NullValue.fromPartial(object.field.all) };
        }
        break;
      }
      case "single": {
        if (object.field?.single !== undefined && object.field?.single !== null) {
          message.field = { $case: "single", single: Fields_SingleField.fromPartial(object.field.single) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseIdiom(): Idiom {
  return { value: "" };
}

export const Idiom: MessageFns<Idiom> = {
  encode(message: Idiom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Idiom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdiom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Idiom {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: Idiom): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Idiom>, I>>(base?: I): Idiom {
    return Idiom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Idiom>, I>>(object: I): Idiom {
    const message = createBaseIdiom();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseData(): Data {
  return { data: undefined };
}

export const Data: MessageFns<Data> = {
  encode(message: Data, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.data?.$case) {
      case "empty":
        NullValue.encode(message.data.empty, writer.uint32(10).fork()).join();
        break;
      case "set":
        Data_SetMultiExpr.encode(message.data.set, writer.uint32(18).fork()).join();
        break;
      case "unset":
        Data_UnsetMultiExpr.encode(message.data.unset, writer.uint32(26).fork()).join();
        break;
      case "patch":
        Value.encode(message.data.patch, writer.uint32(34).fork()).join();
        break;
      case "merge":
        Value.encode(message.data.merge, writer.uint32(42).fork()).join();
        break;
      case "replace":
        Value.encode(message.data.replace, writer.uint32(50).fork()).join();
        break;
      case "content":
        Value.encode(message.data.content, writer.uint32(58).fork()).join();
        break;
      case "value":
        Value.encode(message.data.value, writer.uint32(66).fork()).join();
        break;
      case "values":
        Data_ValuesMultiExpr.encode(message.data.values, writer.uint32(74).fork()).join();
        break;
      case "update":
        Data_SetMultiExpr.encode(message.data.update, writer.uint32(82).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Data {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = { $case: "empty", empty: NullValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = { $case: "set", set: Data_SetMultiExpr.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = { $case: "unset", unset: Data_UnsetMultiExpr.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = { $case: "patch", patch: Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = { $case: "merge", merge: Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.data = { $case: "replace", replace: Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.data = { $case: "content", content: Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.data = { $case: "value", value: Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.data = { $case: "values", values: Data_ValuesMultiExpr.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.data = { $case: "update", update: Data_SetMultiExpr.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data {
    return {
      data: isSet(object.empty)
        ? { $case: "empty", empty: NullValue.fromJSON(object.empty) }
        : isSet(object.set)
        ? { $case: "set", set: Data_SetMultiExpr.fromJSON(object.set) }
        : isSet(object.unset)
        ? { $case: "unset", unset: Data_UnsetMultiExpr.fromJSON(object.unset) }
        : isSet(object.patch)
        ? { $case: "patch", patch: Value.fromJSON(object.patch) }
        : isSet(object.merge)
        ? { $case: "merge", merge: Value.fromJSON(object.merge) }
        : isSet(object.replace)
        ? { $case: "replace", replace: Value.fromJSON(object.replace) }
        : isSet(object.content)
        ? { $case: "content", content: Value.fromJSON(object.content) }
        : isSet(object.value)
        ? { $case: "value", value: Value.fromJSON(object.value) }
        : isSet(object.values)
        ? { $case: "values", values: Data_ValuesMultiExpr.fromJSON(object.values) }
        : isSet(object.update)
        ? { $case: "update", update: Data_SetMultiExpr.fromJSON(object.update) }
        : undefined,
    };
  },

  toJSON(message: Data): unknown {
    const obj: any = {};
    if (message.data?.$case === "empty") {
      obj.empty = NullValue.toJSON(message.data.empty);
    } else if (message.data?.$case === "set") {
      obj.set = Data_SetMultiExpr.toJSON(message.data.set);
    } else if (message.data?.$case === "unset") {
      obj.unset = Data_UnsetMultiExpr.toJSON(message.data.unset);
    } else if (message.data?.$case === "patch") {
      obj.patch = Value.toJSON(message.data.patch);
    } else if (message.data?.$case === "merge") {
      obj.merge = Value.toJSON(message.data.merge);
    } else if (message.data?.$case === "replace") {
      obj.replace = Value.toJSON(message.data.replace);
    } else if (message.data?.$case === "content") {
      obj.content = Value.toJSON(message.data.content);
    } else if (message.data?.$case === "value") {
      obj.value = Value.toJSON(message.data.value);
    } else if (message.data?.$case === "values") {
      obj.values = Data_ValuesMultiExpr.toJSON(message.data.values);
    } else if (message.data?.$case === "update") {
      obj.update = Data_SetMultiExpr.toJSON(message.data.update);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Data>, I>>(base?: I): Data {
    return Data.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Data>, I>>(object: I): Data {
    const message = createBaseData();
    switch (object.data?.$case) {
      case "empty": {
        if (object.data?.empty !== undefined && object.data?.empty !== null) {
          message.data = { $case: "empty", empty: NullValue.fromPartial(object.data.empty) };
        }
        break;
      }
      case "set": {
        if (object.data?.set !== undefined && object.data?.set !== null) {
          message.data = { $case: "set", set: Data_SetMultiExpr.fromPartial(object.data.set) };
        }
        break;
      }
      case "unset": {
        if (object.data?.unset !== undefined && object.data?.unset !== null) {
          message.data = { $case: "unset", unset: Data_UnsetMultiExpr.fromPartial(object.data.unset) };
        }
        break;
      }
      case "patch": {
        if (object.data?.patch !== undefined && object.data?.patch !== null) {
          message.data = { $case: "patch", patch: Value.fromPartial(object.data.patch) };
        }
        break;
      }
      case "merge": {
        if (object.data?.merge !== undefined && object.data?.merge !== null) {
          message.data = { $case: "merge", merge: Value.fromPartial(object.data.merge) };
        }
        break;
      }
      case "replace": {
        if (object.data?.replace !== undefined && object.data?.replace !== null) {
          message.data = { $case: "replace", replace: Value.fromPartial(object.data.replace) };
        }
        break;
      }
      case "content": {
        if (object.data?.content !== undefined && object.data?.content !== null) {
          message.data = { $case: "content", content: Value.fromPartial(object.data.content) };
        }
        break;
      }
      case "value": {
        if (object.data?.value !== undefined && object.data?.value !== null) {
          message.data = { $case: "value", value: Value.fromPartial(object.data.value) };
        }
        break;
      }
      case "values": {
        if (object.data?.values !== undefined && object.data?.values !== null) {
          message.data = { $case: "values", values: Data_ValuesMultiExpr.fromPartial(object.data.values) };
        }
        break;
      }
      case "update": {
        if (object.data?.update !== undefined && object.data?.update !== null) {
          message.data = { $case: "update", update: Data_SetMultiExpr.fromPartial(object.data.update) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseData_SetExpr(): Data_SetExpr {
  return { idiom: undefined, operator: 0, value: undefined };
}

export const Data_SetExpr: MessageFns<Data_SetExpr> = {
  encode(message: Data_SetExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idiom !== undefined) {
      Idiom.encode(message.idiom, writer.uint32(10).fork()).join();
    }
    if (message.operator !== 0) {
      writer.uint32(16).int32(message.operator);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Data_SetExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData_SetExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.idiom = Idiom.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data_SetExpr {
    return {
      idiom: isSet(object.idiom) ? Idiom.fromJSON(object.idiom) : undefined,
      operator: isSet(object.operator) ? operatorFromJSON(object.operator) : 0,
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Data_SetExpr): unknown {
    const obj: any = {};
    if (message.idiom !== undefined) {
      obj.idiom = Idiom.toJSON(message.idiom);
    }
    if (message.operator !== 0) {
      obj.operator = operatorToJSON(message.operator);
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Data_SetExpr>, I>>(base?: I): Data_SetExpr {
    return Data_SetExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Data_SetExpr>, I>>(object: I): Data_SetExpr {
    const message = createBaseData_SetExpr();
    message.idiom = (object.idiom !== undefined && object.idiom !== null) ? Idiom.fromPartial(object.idiom) : undefined;
    message.operator = object.operator ?? 0;
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseData_SetMultiExpr(): Data_SetMultiExpr {
  return { items: [] };
}

export const Data_SetMultiExpr: MessageFns<Data_SetMultiExpr> = {
  encode(message: Data_SetMultiExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Data_SetExpr.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Data_SetMultiExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData_SetMultiExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Data_SetExpr.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data_SetMultiExpr {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Data_SetExpr.fromJSON(e)) : [],
    };
  },

  toJSON(message: Data_SetMultiExpr): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Data_SetExpr.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Data_SetMultiExpr>, I>>(base?: I): Data_SetMultiExpr {
    return Data_SetMultiExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Data_SetMultiExpr>, I>>(object: I): Data_SetMultiExpr {
    const message = createBaseData_SetMultiExpr();
    message.items = object.items?.map((e) => Data_SetExpr.fromPartial(e)) || [];
    return message;
  },
};

function createBaseData_UnsetMultiExpr(): Data_UnsetMultiExpr {
  return { items: [] };
}

export const Data_UnsetMultiExpr: MessageFns<Data_UnsetMultiExpr> = {
  encode(message: Data_UnsetMultiExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Idiom.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Data_UnsetMultiExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData_UnsetMultiExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Idiom.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data_UnsetMultiExpr {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Idiom.fromJSON(e)) : [] };
  },

  toJSON(message: Data_UnsetMultiExpr): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Idiom.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Data_UnsetMultiExpr>, I>>(base?: I): Data_UnsetMultiExpr {
    return Data_UnsetMultiExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Data_UnsetMultiExpr>, I>>(object: I): Data_UnsetMultiExpr {
    const message = createBaseData_UnsetMultiExpr();
    message.items = object.items?.map((e) => Idiom.fromPartial(e)) || [];
    return message;
  },
};

function createBaseData_IdiomValuePair(): Data_IdiomValuePair {
  return { idiom: undefined, value: undefined };
}

export const Data_IdiomValuePair: MessageFns<Data_IdiomValuePair> = {
  encode(message: Data_IdiomValuePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idiom !== undefined) {
      Idiom.encode(message.idiom, writer.uint32(10).fork()).join();
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Data_IdiomValuePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData_IdiomValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.idiom = Idiom.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data_IdiomValuePair {
    return {
      idiom: isSet(object.idiom) ? Idiom.fromJSON(object.idiom) : undefined,
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Data_IdiomValuePair): unknown {
    const obj: any = {};
    if (message.idiom !== undefined) {
      obj.idiom = Idiom.toJSON(message.idiom);
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Data_IdiomValuePair>, I>>(base?: I): Data_IdiomValuePair {
    return Data_IdiomValuePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Data_IdiomValuePair>, I>>(object: I): Data_IdiomValuePair {
    const message = createBaseData_IdiomValuePair();
    message.idiom = (object.idiom !== undefined && object.idiom !== null) ? Idiom.fromPartial(object.idiom) : undefined;
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseData_ValuesExpr(): Data_ValuesExpr {
  return { items: [] };
}

export const Data_ValuesExpr: MessageFns<Data_ValuesExpr> = {
  encode(message: Data_ValuesExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Data_IdiomValuePair.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Data_ValuesExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData_ValuesExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Data_IdiomValuePair.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data_ValuesExpr {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => Data_IdiomValuePair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Data_ValuesExpr): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Data_IdiomValuePair.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Data_ValuesExpr>, I>>(base?: I): Data_ValuesExpr {
    return Data_ValuesExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Data_ValuesExpr>, I>>(object: I): Data_ValuesExpr {
    const message = createBaseData_ValuesExpr();
    message.items = object.items?.map((e) => Data_IdiomValuePair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseData_ValuesMultiExpr(): Data_ValuesMultiExpr {
  return { items: [] };
}

export const Data_ValuesMultiExpr: MessageFns<Data_ValuesMultiExpr> = {
  encode(message: Data_ValuesMultiExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Data_ValuesExpr.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Data_ValuesMultiExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData_ValuesMultiExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Data_ValuesExpr.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data_ValuesMultiExpr {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Data_ValuesExpr.fromJSON(e)) : [],
    };
  },

  toJSON(message: Data_ValuesMultiExpr): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Data_ValuesExpr.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Data_ValuesMultiExpr>, I>>(base?: I): Data_ValuesMultiExpr {
    return Data_ValuesMultiExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Data_ValuesMultiExpr>, I>>(object: I): Data_ValuesMultiExpr {
    const message = createBaseData_ValuesMultiExpr();
    message.items = object.items?.map((e) => Data_ValuesExpr.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFetchs(): Fetchs {
  return { items: [] };
}

export const Fetchs: MessageFns<Fetchs> = {
  encode(message: Fetchs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fetchs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fetchs {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Value.fromJSON(e)) : [] };
  },

  toJSON(message: Fetchs): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fetchs>, I>>(base?: I): Fetchs {
    return Fetchs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fetchs>, I>>(object: I): Fetchs {
    const message = createBaseFetchs();
    message.items = object.items?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
