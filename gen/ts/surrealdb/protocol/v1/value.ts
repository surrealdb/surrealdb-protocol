// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: surrealdb/protocol/v1/value.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration";
import { Timestamp } from "../../../google/protobuf/timestamp";

export const protobufPackage = "surrealdb.protocol.v1";

/** Null value. */
export interface NullValue {
}

/** Decimal value. */
export interface Decimal {
  value: string;
}

/** UUID value. */
export interface Uuid {
  value: string;
}

/** Point type. */
export interface Point {
  x: number;
  y: number;
}

/** Line type. */
export interface Line {
  points: Point[];
}

/** Polygon type. */
export interface Polygon {
  /** Exterior ring. */
  exterior:
    | Line
    | undefined;
  /** Interior rings. */
  interiors: Line[];
}

/** MultiPoint type. */
export interface MultiPoint {
  points: Point[];
}

/** MultiLine type. */
export interface MultiLine {
  lines: Line[];
}

/** MultiPolygon type. */
export interface MultiPolygon {
  polygons: Polygon[];
}

/** GeometryCollection type. */
export interface GeometryCollection {
  geometries: Geometry[];
}

/** Generic geometry type. */
export interface Geometry {
  geometry?:
    | { $case: "point"; point: Point }
    | { $case: "line"; line: Line }
    | { $case: "polygon"; polygon: Polygon }
    | { $case: "multiPoint"; multiPoint: MultiPoint }
    | { $case: "multiLine"; multiLine: MultiLine }
    | { $case: "multiPolygon"; multiPolygon: MultiPolygon }
    | { $case: "collection"; collection: GeometryCollection }
    | undefined;
}

/** Record ID type. */
export interface RecordId {
  /** Table name. */
  table: string;
  /** Record ID. */
  id: Id | undefined;
}

/** File type. */
export interface File {
  /** Bucket name. */
  bucket: string;
  /** File key. */
  key: string;
}

/** Array type. */
export interface Array {
  values: Value[];
}

/** Object type. */
export interface Object {
  items: { [key: string]: Value };
}

export interface Object_ItemsEntry {
  key: string;
  value: Value | undefined;
}

/** Value bound type. */
export interface ValueBound {
  bound?: { $case: "inclusive"; inclusive: Value } | { $case: "exclusive"; exclusive: Value } | {
    $case: "unbounded";
    unbounded: NullValue;
  } | undefined;
}

/** Range type. */
export interface Range {
  start: ValueBound | undefined;
  end: ValueBound | undefined;
}

/** Value type. */
export interface Value {
  value?:
    | { $case: "null"; null: NullValue }
    | { $case: "bool"; bool: boolean }
    | { $case: "int64"; int64: bigint }
    | { $case: "uint64"; uint64: bigint }
    | { $case: "float64"; float64: number }
    | { $case: "string"; string: string }
    | { $case: "bytes"; bytes: Uint8Array }
    | { $case: "decimal"; decimal: Decimal }
    | { $case: "duration"; duration: Duration }
    | { $case: "datetime"; datetime: Date }
    | { $case: "uuid"; uuid: Uuid }
    | { $case: "array"; array: Array }
    | { $case: "object"; object: Object }
    | { $case: "geometry"; geometry: Geometry }
    | { $case: "recordId"; recordId: RecordId }
    | { $case: "file"; file: File }
    | { $case: "range"; range: Range }
    | undefined;
}

/** ID type. */
export interface Id {
  id?:
    | { $case: "int64"; int64: bigint }
    | { $case: "string"; string: string }
    | { $case: "uuid"; uuid: Uuid }
    | { $case: "array"; array: Array }
    | { $case: "range"; range: Range }
    | undefined;
}

/** Variables. */
export interface Variables {
  variables: { [key: string]: Value };
}

export interface Variables_VariablesEntry {
  key: string;
  value: Value | undefined;
}

function createBaseNullValue(): NullValue {
  return {};
}

export const NullValue: MessageFns<NullValue> = {
  encode(_: NullValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NullValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNullValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NullValue {
    return {};
  },

  toJSON(_: NullValue): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NullValue>, I>>(base?: I): NullValue {
    return NullValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NullValue>, I>>(_: I): NullValue {
    const message = createBaseNullValue();
    return message;
  },
};

function createBaseDecimal(): Decimal {
  return { value: "" };
}

export const Decimal: MessageFns<Decimal> = {
  encode(message: Decimal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Decimal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecimal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Decimal {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: Decimal): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Decimal>, I>>(base?: I): Decimal {
    return Decimal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Decimal>, I>>(object: I): Decimal {
    const message = createBaseDecimal();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUuid(): Uuid {
  return { value: "" };
}

export const Uuid: MessageFns<Uuid> = {
  encode(message: Uuid, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Uuid {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUuid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Uuid {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: Uuid): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Uuid>, I>>(base?: I): Uuid {
    return Uuid.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Uuid>, I>>(object: I): Uuid {
    const message = createBaseUuid();
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePoint(): Point {
  return { x: 0, y: 0 };
}

export const Point: MessageFns<Point> = {
  encode(message: Point, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Point): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point>, I>>(base?: I): Point {
    return Point.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point>, I>>(object: I): Point {
    const message = createBasePoint();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseLine(): Line {
  return { points: [] };
}

export const Line: MessageFns<Line> = {
  encode(message: Line, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.points) {
      Point.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Line {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.points.push(Point.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Line {
    return { points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Point.fromJSON(e)) : [] };
  },

  toJSON(message: Line): unknown {
    const obj: any = {};
    if (message.points?.length) {
      obj.points = message.points.map((e) => Point.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Line>, I>>(base?: I): Line {
    return Line.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Line>, I>>(object: I): Line {
    const message = createBaseLine();
    message.points = object.points?.map((e) => Point.fromPartial(e)) || [];
    return message;
  },
};

function createBasePolygon(): Polygon {
  return { exterior: undefined, interiors: [] };
}

export const Polygon: MessageFns<Polygon> = {
  encode(message: Polygon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exterior !== undefined) {
      Line.encode(message.exterior, writer.uint32(10).fork()).join();
    }
    for (const v of message.interiors) {
      Line.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Polygon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exterior = Line.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.interiors.push(Line.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Polygon {
    return {
      exterior: isSet(object.exterior) ? Line.fromJSON(object.exterior) : undefined,
      interiors: globalThis.Array.isArray(object?.interiors) ? object.interiors.map((e: any) => Line.fromJSON(e)) : [],
    };
  },

  toJSON(message: Polygon): unknown {
    const obj: any = {};
    if (message.exterior !== undefined) {
      obj.exterior = Line.toJSON(message.exterior);
    }
    if (message.interiors?.length) {
      obj.interiors = message.interiors.map((e) => Line.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Polygon>, I>>(base?: I): Polygon {
    return Polygon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Polygon>, I>>(object: I): Polygon {
    const message = createBasePolygon();
    message.exterior = (object.exterior !== undefined && object.exterior !== null)
      ? Line.fromPartial(object.exterior)
      : undefined;
    message.interiors = object.interiors?.map((e) => Line.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiPoint(): MultiPoint {
  return { points: [] };
}

export const MultiPoint: MessageFns<MultiPoint> = {
  encode(message: MultiPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.points) {
      Point.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.points.push(Point.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiPoint {
    return { points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Point.fromJSON(e)) : [] };
  },

  toJSON(message: MultiPoint): unknown {
    const obj: any = {};
    if (message.points?.length) {
      obj.points = message.points.map((e) => Point.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiPoint>, I>>(base?: I): MultiPoint {
    return MultiPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiPoint>, I>>(object: I): MultiPoint {
    const message = createBaseMultiPoint();
    message.points = object.points?.map((e) => Point.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiLine(): MultiLine {
  return { lines: [] };
}

export const MultiLine: MessageFns<MultiLine> = {
  encode(message: MultiLine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lines) {
      Line.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lines.push(Line.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiLine {
    return { lines: globalThis.Array.isArray(object?.lines) ? object.lines.map((e: any) => Line.fromJSON(e)) : [] };
  },

  toJSON(message: MultiLine): unknown {
    const obj: any = {};
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => Line.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiLine>, I>>(base?: I): MultiLine {
    return MultiLine.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLine>, I>>(object: I): MultiLine {
    const message = createBaseMultiLine();
    message.lines = object.lines?.map((e) => Line.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiPolygon(): MultiPolygon {
  return { polygons: [] };
}

export const MultiPolygon: MessageFns<MultiPolygon> = {
  encode(message: MultiPolygon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.polygons) {
      Polygon.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiPolygon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiPolygon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.polygons.push(Polygon.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiPolygon {
    return {
      polygons: globalThis.Array.isArray(object?.polygons) ? object.polygons.map((e: any) => Polygon.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiPolygon): unknown {
    const obj: any = {};
    if (message.polygons?.length) {
      obj.polygons = message.polygons.map((e) => Polygon.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiPolygon>, I>>(base?: I): MultiPolygon {
    return MultiPolygon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiPolygon>, I>>(object: I): MultiPolygon {
    const message = createBaseMultiPolygon();
    message.polygons = object.polygons?.map((e) => Polygon.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGeometryCollection(): GeometryCollection {
  return { geometries: [] };
}

export const GeometryCollection: MessageFns<GeometryCollection> = {
  encode(message: GeometryCollection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.geometries) {
      Geometry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeometryCollection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeometryCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.geometries.push(Geometry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeometryCollection {
    return {
      geometries: globalThis.Array.isArray(object?.geometries)
        ? object.geometries.map((e: any) => Geometry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GeometryCollection): unknown {
    const obj: any = {};
    if (message.geometries?.length) {
      obj.geometries = message.geometries.map((e) => Geometry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeometryCollection>, I>>(base?: I): GeometryCollection {
    return GeometryCollection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeometryCollection>, I>>(object: I): GeometryCollection {
    const message = createBaseGeometryCollection();
    message.geometries = object.geometries?.map((e) => Geometry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGeometry(): Geometry {
  return { geometry: undefined };
}

export const Geometry: MessageFns<Geometry> = {
  encode(message: Geometry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.geometry?.$case) {
      case "point":
        Point.encode(message.geometry.point, writer.uint32(10).fork()).join();
        break;
      case "line":
        Line.encode(message.geometry.line, writer.uint32(18).fork()).join();
        break;
      case "polygon":
        Polygon.encode(message.geometry.polygon, writer.uint32(26).fork()).join();
        break;
      case "multiPoint":
        MultiPoint.encode(message.geometry.multiPoint, writer.uint32(34).fork()).join();
        break;
      case "multiLine":
        MultiLine.encode(message.geometry.multiLine, writer.uint32(42).fork()).join();
        break;
      case "multiPolygon":
        MultiPolygon.encode(message.geometry.multiPolygon, writer.uint32(50).fork()).join();
        break;
      case "collection":
        GeometryCollection.encode(message.geometry.collection, writer.uint32(58).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Geometry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeometry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.geometry = { $case: "point", point: Point.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.geometry = { $case: "line", line: Line.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.geometry = { $case: "polygon", polygon: Polygon.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.geometry = { $case: "multiPoint", multiPoint: MultiPoint.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.geometry = { $case: "multiLine", multiLine: MultiLine.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.geometry = { $case: "multiPolygon", multiPolygon: MultiPolygon.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.geometry = { $case: "collection", collection: GeometryCollection.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Geometry {
    return {
      geometry: isSet(object.point)
        ? { $case: "point", point: Point.fromJSON(object.point) }
        : isSet(object.line)
        ? { $case: "line", line: Line.fromJSON(object.line) }
        : isSet(object.polygon)
        ? { $case: "polygon", polygon: Polygon.fromJSON(object.polygon) }
        : isSet(object.multiPoint)
        ? { $case: "multiPoint", multiPoint: MultiPoint.fromJSON(object.multiPoint) }
        : isSet(object.multiLine)
        ? { $case: "multiLine", multiLine: MultiLine.fromJSON(object.multiLine) }
        : isSet(object.multiPolygon)
        ? { $case: "multiPolygon", multiPolygon: MultiPolygon.fromJSON(object.multiPolygon) }
        : isSet(object.collection)
        ? { $case: "collection", collection: GeometryCollection.fromJSON(object.collection) }
        : undefined,
    };
  },

  toJSON(message: Geometry): unknown {
    const obj: any = {};
    if (message.geometry?.$case === "point") {
      obj.point = Point.toJSON(message.geometry.point);
    } else if (message.geometry?.$case === "line") {
      obj.line = Line.toJSON(message.geometry.line);
    } else if (message.geometry?.$case === "polygon") {
      obj.polygon = Polygon.toJSON(message.geometry.polygon);
    } else if (message.geometry?.$case === "multiPoint") {
      obj.multiPoint = MultiPoint.toJSON(message.geometry.multiPoint);
    } else if (message.geometry?.$case === "multiLine") {
      obj.multiLine = MultiLine.toJSON(message.geometry.multiLine);
    } else if (message.geometry?.$case === "multiPolygon") {
      obj.multiPolygon = MultiPolygon.toJSON(message.geometry.multiPolygon);
    } else if (message.geometry?.$case === "collection") {
      obj.collection = GeometryCollection.toJSON(message.geometry.collection);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Geometry>, I>>(base?: I): Geometry {
    return Geometry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Geometry>, I>>(object: I): Geometry {
    const message = createBaseGeometry();
    switch (object.geometry?.$case) {
      case "point": {
        if (object.geometry?.point !== undefined && object.geometry?.point !== null) {
          message.geometry = { $case: "point", point: Point.fromPartial(object.geometry.point) };
        }
        break;
      }
      case "line": {
        if (object.geometry?.line !== undefined && object.geometry?.line !== null) {
          message.geometry = { $case: "line", line: Line.fromPartial(object.geometry.line) };
        }
        break;
      }
      case "polygon": {
        if (object.geometry?.polygon !== undefined && object.geometry?.polygon !== null) {
          message.geometry = { $case: "polygon", polygon: Polygon.fromPartial(object.geometry.polygon) };
        }
        break;
      }
      case "multiPoint": {
        if (object.geometry?.multiPoint !== undefined && object.geometry?.multiPoint !== null) {
          message.geometry = { $case: "multiPoint", multiPoint: MultiPoint.fromPartial(object.geometry.multiPoint) };
        }
        break;
      }
      case "multiLine": {
        if (object.geometry?.multiLine !== undefined && object.geometry?.multiLine !== null) {
          message.geometry = { $case: "multiLine", multiLine: MultiLine.fromPartial(object.geometry.multiLine) };
        }
        break;
      }
      case "multiPolygon": {
        if (object.geometry?.multiPolygon !== undefined && object.geometry?.multiPolygon !== null) {
          message.geometry = {
            $case: "multiPolygon",
            multiPolygon: MultiPolygon.fromPartial(object.geometry.multiPolygon),
          };
        }
        break;
      }
      case "collection": {
        if (object.geometry?.collection !== undefined && object.geometry?.collection !== null) {
          message.geometry = {
            $case: "collection",
            collection: GeometryCollection.fromPartial(object.geometry.collection),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseRecordId(): RecordId {
  return { table: "", id: undefined };
}

export const RecordId: MessageFns<RecordId> = {
  encode(message: RecordId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    if (message.id !== undefined) {
      Id.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecordId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = Id.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecordId {
    return {
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      id: isSet(object.id) ? Id.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: RecordId): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.id !== undefined) {
      obj.id = Id.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecordId>, I>>(base?: I): RecordId {
    return RecordId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecordId>, I>>(object: I): RecordId {
    const message = createBaseRecordId();
    message.table = object.table ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Id.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseFile(): File {
  return { bucket: "", key: "" };
}

export const File: MessageFns<File> = {
  encode(message: File, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): File {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): File {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: File): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<File>, I>>(base?: I): File {
    return File.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<File>, I>>(object: I): File {
    const message = createBaseFile();
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseArray(): Array {
  return { values: [] };
}

export const Array: MessageFns<Array> = {
  encode(message: Array, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Array {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Array {
    return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Value.fromJSON(e)) : [] };
  },

  toJSON(message: Array): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Array>, I>>(base?: I): Array {
    return Array.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Array>, I>>(object: I): Array {
    const message = createBaseArray();
    message.values = object.values?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseObject(): Object {
  return { items: {} };
}

export const Object: MessageFns<Object> = {
  encode(message: Object, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.items).forEach(([key, value]) => {
      Object_ItemsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Object {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Object_ItemsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.items[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Object {
    return {
      items: isObject(object.items)
        ? Object.entries(object.items).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Object): unknown {
    const obj: any = {};
    if (message.items) {
      const entries = Object.entries(message.items);
      if (entries.length > 0) {
        obj.items = {};
        entries.forEach(([k, v]) => {
          obj.items[k] = Value.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Object>, I>>(base?: I): Object {
    return Object.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Object>, I>>(object: I): Object {
    const message = createBaseObject();
    message.items = Object.entries(object.items ?? {}).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseObject_ItemsEntry(): Object_ItemsEntry {
  return { key: "", value: undefined };
}

export const Object_ItemsEntry: MessageFns<Object_ItemsEntry> = {
  encode(message: Object_ItemsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Object_ItemsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObject_ItemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Object_ItemsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Object_ItemsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Object_ItemsEntry>, I>>(base?: I): Object_ItemsEntry {
    return Object_ItemsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Object_ItemsEntry>, I>>(object: I): Object_ItemsEntry {
    const message = createBaseObject_ItemsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseValueBound(): ValueBound {
  return { bound: undefined };
}

export const ValueBound: MessageFns<ValueBound> = {
  encode(message: ValueBound, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.bound?.$case) {
      case "inclusive":
        Value.encode(message.bound.inclusive, writer.uint32(10).fork()).join();
        break;
      case "exclusive":
        Value.encode(message.bound.exclusive, writer.uint32(18).fork()).join();
        break;
      case "unbounded":
        NullValue.encode(message.bound.unbounded, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValueBound {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValueBound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bound = { $case: "inclusive", inclusive: Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bound = { $case: "exclusive", exclusive: Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bound = { $case: "unbounded", unbounded: NullValue.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValueBound {
    return {
      bound: isSet(object.inclusive)
        ? { $case: "inclusive", inclusive: Value.fromJSON(object.inclusive) }
        : isSet(object.exclusive)
        ? { $case: "exclusive", exclusive: Value.fromJSON(object.exclusive) }
        : isSet(object.unbounded)
        ? { $case: "unbounded", unbounded: NullValue.fromJSON(object.unbounded) }
        : undefined,
    };
  },

  toJSON(message: ValueBound): unknown {
    const obj: any = {};
    if (message.bound?.$case === "inclusive") {
      obj.inclusive = Value.toJSON(message.bound.inclusive);
    } else if (message.bound?.$case === "exclusive") {
      obj.exclusive = Value.toJSON(message.bound.exclusive);
    } else if (message.bound?.$case === "unbounded") {
      obj.unbounded = NullValue.toJSON(message.bound.unbounded);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValueBound>, I>>(base?: I): ValueBound {
    return ValueBound.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValueBound>, I>>(object: I): ValueBound {
    const message = createBaseValueBound();
    switch (object.bound?.$case) {
      case "inclusive": {
        if (object.bound?.inclusive !== undefined && object.bound?.inclusive !== null) {
          message.bound = { $case: "inclusive", inclusive: Value.fromPartial(object.bound.inclusive) };
        }
        break;
      }
      case "exclusive": {
        if (object.bound?.exclusive !== undefined && object.bound?.exclusive !== null) {
          message.bound = { $case: "exclusive", exclusive: Value.fromPartial(object.bound.exclusive) };
        }
        break;
      }
      case "unbounded": {
        if (object.bound?.unbounded !== undefined && object.bound?.unbounded !== null) {
          message.bound = { $case: "unbounded", unbounded: NullValue.fromPartial(object.bound.unbounded) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseRange(): Range {
  return { start: undefined, end: undefined };
}

export const Range: MessageFns<Range> = {
  encode(message: Range, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      ValueBound.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.end !== undefined) {
      ValueBound.encode(message.end, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Range {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.start = ValueBound.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.end = ValueBound.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Range {
    return {
      start: isSet(object.start) ? ValueBound.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? ValueBound.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: Range): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = ValueBound.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = ValueBound.toJSON(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Range>, I>>(base?: I): Range {
    return Range.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Range>, I>>(object: I): Range {
    const message = createBaseRange();
    message.start = (object.start !== undefined && object.start !== null)
      ? ValueBound.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? ValueBound.fromPartial(object.end) : undefined;
    return message;
  },
};

function createBaseValue(): Value {
  return { value: undefined };
}

export const Value: MessageFns<Value> = {
  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.value?.$case) {
      case "null":
        NullValue.encode(message.value.null, writer.uint32(10).fork()).join();
        break;
      case "bool":
        writer.uint32(16).bool(message.value.bool);
        break;
      case "int64":
        if (BigInt.asIntN(64, message.value.int64) !== message.value.int64) {
          throw new globalThis.Error("value provided for field message.value.int64 of type int64 too large");
        }
        writer.uint32(24).int64(message.value.int64);
        break;
      case "uint64":
        if (BigInt.asUintN(64, message.value.uint64) !== message.value.uint64) {
          throw new globalThis.Error("value provided for field message.value.uint64 of type uint64 too large");
        }
        writer.uint32(32).uint64(message.value.uint64);
        break;
      case "float64":
        writer.uint32(41).double(message.value.float64);
        break;
      case "string":
        writer.uint32(50).string(message.value.string);
        break;
      case "bytes":
        writer.uint32(58).bytes(message.value.bytes);
        break;
      case "decimal":
        Decimal.encode(message.value.decimal, writer.uint32(66).fork()).join();
        break;
      case "duration":
        Duration.encode(message.value.duration, writer.uint32(74).fork()).join();
        break;
      case "datetime":
        Timestamp.encode(toTimestamp(message.value.datetime), writer.uint32(82).fork()).join();
        break;
      case "uuid":
        Uuid.encode(message.value.uuid, writer.uint32(90).fork()).join();
        break;
      case "array":
        Array.encode(message.value.array, writer.uint32(98).fork()).join();
        break;
      case "object":
        Object.encode(message.value.object, writer.uint32(106).fork()).join();
        break;
      case "geometry":
        Geometry.encode(message.value.geometry, writer.uint32(114).fork()).join();
        break;
      case "recordId":
        RecordId.encode(message.value.recordId, writer.uint32(122).fork()).join();
        break;
      case "file":
        File.encode(message.value.file, writer.uint32(130).fork()).join();
        break;
      case "range":
        Range.encode(message.value.range, writer.uint32(138).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = { $case: "null", null: NullValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = { $case: "bool", bool: reader.bool() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = { $case: "int64", int64: reader.int64() as bigint };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.value = { $case: "uint64", uint64: reader.uint64() as bigint };
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.value = { $case: "float64", float64: reader.double() };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.value = { $case: "string", string: reader.string() };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.value = { $case: "bytes", bytes: reader.bytes() };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.value = { $case: "decimal", decimal: Decimal.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.value = { $case: "duration", duration: Duration.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.value = { $case: "datetime", datetime: fromTimestamp(Timestamp.decode(reader, reader.uint32())) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.value = { $case: "uuid", uuid: Uuid.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.value = { $case: "array", array: Array.decode(reader, reader.uint32()) };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.value = { $case: "object", object: Object.decode(reader, reader.uint32()) };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.value = { $case: "geometry", geometry: Geometry.decode(reader, reader.uint32()) };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.value = { $case: "recordId", recordId: RecordId.decode(reader, reader.uint32()) };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.value = { $case: "file", file: File.decode(reader, reader.uint32()) };
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.value = { $case: "range", range: Range.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      value: isSet(object.null)
        ? { $case: "null", null: NullValue.fromJSON(object.null) }
        : isSet(object.bool)
        ? { $case: "bool", bool: globalThis.Boolean(object.bool) }
        : isSet(object.int64)
        ? { $case: "int64", int64: BigInt(object.int64) }
        : isSet(object.uint64)
        ? { $case: "uint64", uint64: BigInt(object.uint64) }
        : isSet(object.float64)
        ? { $case: "float64", float64: globalThis.Number(object.float64) }
        : isSet(object.string)
        ? { $case: "string", string: globalThis.String(object.string) }
        : isSet(object.bytes)
        ? { $case: "bytes", bytes: bytesFromBase64(object.bytes) }
        : isSet(object.decimal)
        ? { $case: "decimal", decimal: Decimal.fromJSON(object.decimal) }
        : isSet(object.duration)
        ? { $case: "duration", duration: Duration.fromJSON(object.duration) }
        : isSet(object.datetime)
        ? { $case: "datetime", datetime: fromJsonTimestamp(object.datetime) }
        : isSet(object.uuid)
        ? { $case: "uuid", uuid: Uuid.fromJSON(object.uuid) }
        : isSet(object.array)
        ? { $case: "array", array: Array.fromJSON(object.array) }
        : isSet(object.object)
        ? { $case: "object", object: Object.fromJSON(object.object) }
        : isSet(object.geometry)
        ? { $case: "geometry", geometry: Geometry.fromJSON(object.geometry) }
        : isSet(object.recordId)
        ? { $case: "recordId", recordId: RecordId.fromJSON(object.recordId) }
        : isSet(object.file)
        ? { $case: "file", file: File.fromJSON(object.file) }
        : isSet(object.range)
        ? { $case: "range", range: Range.fromJSON(object.range) }
        : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.value?.$case === "null") {
      obj.null = NullValue.toJSON(message.value.null);
    } else if (message.value?.$case === "bool") {
      obj.bool = message.value.bool;
    } else if (message.value?.$case === "int64") {
      obj.int64 = message.value.int64.toString();
    } else if (message.value?.$case === "uint64") {
      obj.uint64 = message.value.uint64.toString();
    } else if (message.value?.$case === "float64") {
      obj.float64 = message.value.float64;
    } else if (message.value?.$case === "string") {
      obj.string = message.value.string;
    } else if (message.value?.$case === "bytes") {
      obj.bytes = base64FromBytes(message.value.bytes);
    } else if (message.value?.$case === "decimal") {
      obj.decimal = Decimal.toJSON(message.value.decimal);
    } else if (message.value?.$case === "duration") {
      obj.duration = Duration.toJSON(message.value.duration);
    } else if (message.value?.$case === "datetime") {
      obj.datetime = message.value.datetime.toISOString();
    } else if (message.value?.$case === "uuid") {
      obj.uuid = Uuid.toJSON(message.value.uuid);
    } else if (message.value?.$case === "array") {
      obj.array = Array.toJSON(message.value.array);
    } else if (message.value?.$case === "object") {
      obj.object = Object.toJSON(message.value.object);
    } else if (message.value?.$case === "geometry") {
      obj.geometry = Geometry.toJSON(message.value.geometry);
    } else if (message.value?.$case === "recordId") {
      obj.recordId = RecordId.toJSON(message.value.recordId);
    } else if (message.value?.$case === "file") {
      obj.file = File.toJSON(message.value.file);
    } else if (message.value?.$case === "range") {
      obj.range = Range.toJSON(message.value.range);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {
    return Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {
    const message = createBaseValue();
    switch (object.value?.$case) {
      case "null": {
        if (object.value?.null !== undefined && object.value?.null !== null) {
          message.value = { $case: "null", null: NullValue.fromPartial(object.value.null) };
        }
        break;
      }
      case "bool": {
        if (object.value?.bool !== undefined && object.value?.bool !== null) {
          message.value = { $case: "bool", bool: object.value.bool };
        }
        break;
      }
      case "int64": {
        if (object.value?.int64 !== undefined && object.value?.int64 !== null) {
          message.value = { $case: "int64", int64: object.value.int64 };
        }
        break;
      }
      case "uint64": {
        if (object.value?.uint64 !== undefined && object.value?.uint64 !== null) {
          message.value = { $case: "uint64", uint64: object.value.uint64 };
        }
        break;
      }
      case "float64": {
        if (object.value?.float64 !== undefined && object.value?.float64 !== null) {
          message.value = { $case: "float64", float64: object.value.float64 };
        }
        break;
      }
      case "string": {
        if (object.value?.string !== undefined && object.value?.string !== null) {
          message.value = { $case: "string", string: object.value.string };
        }
        break;
      }
      case "bytes": {
        if (object.value?.bytes !== undefined && object.value?.bytes !== null) {
          message.value = { $case: "bytes", bytes: object.value.bytes };
        }
        break;
      }
      case "decimal": {
        if (object.value?.decimal !== undefined && object.value?.decimal !== null) {
          message.value = { $case: "decimal", decimal: Decimal.fromPartial(object.value.decimal) };
        }
        break;
      }
      case "duration": {
        if (object.value?.duration !== undefined && object.value?.duration !== null) {
          message.value = { $case: "duration", duration: Duration.fromPartial(object.value.duration) };
        }
        break;
      }
      case "datetime": {
        if (object.value?.datetime !== undefined && object.value?.datetime !== null) {
          message.value = { $case: "datetime", datetime: object.value.datetime };
        }
        break;
      }
      case "uuid": {
        if (object.value?.uuid !== undefined && object.value?.uuid !== null) {
          message.value = { $case: "uuid", uuid: Uuid.fromPartial(object.value.uuid) };
        }
        break;
      }
      case "array": {
        if (object.value?.array !== undefined && object.value?.array !== null) {
          message.value = { $case: "array", array: Array.fromPartial(object.value.array) };
        }
        break;
      }
      case "object": {
        if (object.value?.object !== undefined && object.value?.object !== null) {
          message.value = { $case: "object", object: Object.fromPartial(object.value.object) };
        }
        break;
      }
      case "geometry": {
        if (object.value?.geometry !== undefined && object.value?.geometry !== null) {
          message.value = { $case: "geometry", geometry: Geometry.fromPartial(object.value.geometry) };
        }
        break;
      }
      case "recordId": {
        if (object.value?.recordId !== undefined && object.value?.recordId !== null) {
          message.value = { $case: "recordId", recordId: RecordId.fromPartial(object.value.recordId) };
        }
        break;
      }
      case "file": {
        if (object.value?.file !== undefined && object.value?.file !== null) {
          message.value = { $case: "file", file: File.fromPartial(object.value.file) };
        }
        break;
      }
      case "range": {
        if (object.value?.range !== undefined && object.value?.range !== null) {
          message.value = { $case: "range", range: Range.fromPartial(object.value.range) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseId(): Id {
  return { id: undefined };
}

export const Id: MessageFns<Id> = {
  encode(message: Id, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.id?.$case) {
      case "int64":
        if (BigInt.asIntN(64, message.id.int64) !== message.id.int64) {
          throw new globalThis.Error("value provided for field message.id.int64 of type int64 too large");
        }
        writer.uint32(8).int64(message.id.int64);
        break;
      case "string":
        writer.uint32(18).string(message.id.string);
        break;
      case "uuid":
        Uuid.encode(message.id.uuid, writer.uint32(26).fork()).join();
        break;
      case "array":
        Array.encode(message.id.array, writer.uint32(34).fork()).join();
        break;
      case "range":
        Range.encode(message.id.range, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Id {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = { $case: "int64", int64: reader.int64() as bigint };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = { $case: "string", string: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = { $case: "uuid", uuid: Uuid.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = { $case: "array", array: Array.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.id = { $case: "range", range: Range.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Id {
    return {
      id: isSet(object.int64)
        ? { $case: "int64", int64: BigInt(object.int64) }
        : isSet(object.string)
        ? { $case: "string", string: globalThis.String(object.string) }
        : isSet(object.uuid)
        ? { $case: "uuid", uuid: Uuid.fromJSON(object.uuid) }
        : isSet(object.array)
        ? { $case: "array", array: Array.fromJSON(object.array) }
        : isSet(object.range)
        ? { $case: "range", range: Range.fromJSON(object.range) }
        : undefined,
    };
  },

  toJSON(message: Id): unknown {
    const obj: any = {};
    if (message.id?.$case === "int64") {
      obj.int64 = message.id.int64.toString();
    } else if (message.id?.$case === "string") {
      obj.string = message.id.string;
    } else if (message.id?.$case === "uuid") {
      obj.uuid = Uuid.toJSON(message.id.uuid);
    } else if (message.id?.$case === "array") {
      obj.array = Array.toJSON(message.id.array);
    } else if (message.id?.$case === "range") {
      obj.range = Range.toJSON(message.id.range);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Id>, I>>(base?: I): Id {
    return Id.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Id>, I>>(object: I): Id {
    const message = createBaseId();
    switch (object.id?.$case) {
      case "int64": {
        if (object.id?.int64 !== undefined && object.id?.int64 !== null) {
          message.id = { $case: "int64", int64: object.id.int64 };
        }
        break;
      }
      case "string": {
        if (object.id?.string !== undefined && object.id?.string !== null) {
          message.id = { $case: "string", string: object.id.string };
        }
        break;
      }
      case "uuid": {
        if (object.id?.uuid !== undefined && object.id?.uuid !== null) {
          message.id = { $case: "uuid", uuid: Uuid.fromPartial(object.id.uuid) };
        }
        break;
      }
      case "array": {
        if (object.id?.array !== undefined && object.id?.array !== null) {
          message.id = { $case: "array", array: Array.fromPartial(object.id.array) };
        }
        break;
      }
      case "range": {
        if (object.id?.range !== undefined && object.id?.range !== null) {
          message.id = { $case: "range", range: Range.fromPartial(object.id.range) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseVariables(): Variables {
  return { variables: {} };
}

export const Variables: MessageFns<Variables> = {
  encode(message: Variables, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.variables).forEach(([key, value]) => {
      Variables_VariablesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variables {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariables();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Variables_VariablesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.variables[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variables {
    return {
      variables: isObject(object.variables)
        ? Object.entries(object.variables).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Variables): unknown {
    const obj: any = {};
    if (message.variables) {
      const entries = Object.entries(message.variables);
      if (entries.length > 0) {
        obj.variables = {};
        entries.forEach(([k, v]) => {
          obj.variables[k] = Value.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Variables>, I>>(base?: I): Variables {
    return Variables.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Variables>, I>>(object: I): Variables {
    const message = createBaseVariables();
    message.variables = Object.entries(object.variables ?? {}).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseVariables_VariablesEntry(): Variables_VariablesEntry {
  return { key: "", value: undefined };
}

export const Variables_VariablesEntry: MessageFns<Variables_VariablesEntry> = {
  encode(message: Variables_VariablesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variables_VariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariables_VariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variables_VariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Variables_VariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Variables_VariablesEntry>, I>>(base?: I): Variables_VariablesEntry {
    return Variables_VariablesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Variables_VariablesEntry>, I>>(object: I): Variables_VariablesEntry {
    const message = createBaseVariables_VariablesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds.toString()) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
