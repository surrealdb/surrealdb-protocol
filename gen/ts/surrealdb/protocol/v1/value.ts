// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: surrealdb/protocol/v1/value.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration";
import { Timestamp } from "../../../google/protobuf/timestamp";

export const protobufPackage = "surrealdb.protocol.v1";

/** Null value. */
export interface NullValue {
}

/** Boolean value. */
export interface BoolValue {
  value: boolean;
}

/** 64-bit signed integer value. */
export interface Int64Value {
  value: bigint;
}

/** 64-bit unsigned integer value. */
export interface UInt64Value {
  value: bigint;
}

/** 64-bit floating point value. */
export interface Float64Value {
  value: number;
}

/** String value. */
export interface StringValue {
  value: string;
}

/** Bytes value. */
export interface BytesValue {
  value: Uint8Array;
}

/** Decimal value. */
export interface DecimalValue {
  value: string;
}

/** UUID value. */
export interface UuidValue {
  value: string;
}

/** Point type. */
export interface Point {
  x: number;
  y: number;
}

/** LineString type. */
export interface LineString {
  points: Point[];
}

/** Polygon type. */
export interface Polygon {
  /** Exterior ring. */
  exterior:
    | LineString
    | undefined;
  /** Interior rings. */
  interiors: LineString[];
}

/** MultiPoint type. */
export interface MultiPoint {
  points: Point[];
}

/** MultiLineString type. */
export interface MultiLineString {
  lines: LineString[];
}

/** MultiPolygon type. */
export interface MultiPolygon {
  polygons: Polygon[];
}

/** GeometryCollection type. */
export interface GeometryCollection {
  geometries: Geometry[];
}

/** Generic geometry type. */
export interface Geometry {
  geometry?:
    | { $case: "point"; point: Point }
    | { $case: "lineString"; lineString: LineString }
    | { $case: "polygon"; polygon: Polygon }
    | { $case: "multiPoint"; multiPoint: MultiPoint }
    | { $case: "multiLineString"; multiLineString: MultiLineString }
    | { $case: "multiPolygon"; multiPolygon: MultiPolygon }
    | { $case: "collection"; collection: GeometryCollection }
    | undefined;
}

/** Record ID type. */
export interface RecordId {
  /** Table name. */
  table: string;
  /** Record ID. */
  id: Id | undefined;
}

/** File type. */
export interface File {
  /** Bucket name. */
  bucket: string;
  /** File key. */
  key: string;
}

/** Array type. */
export interface Array {
  values: Value[];
}

/** Object type. */
export interface Object {
  items: { [key: string]: Value };
}

export interface Object_ItemsEntry {
  key: string;
  value: Value | undefined;
}

/** Value type. */
export interface Value {
  value?:
    | { $case: "null"; null: NullValue }
    | { $case: "bool"; bool: BoolValue }
    | { $case: "int64"; int64: Int64Value }
    | { $case: "uint64"; uint64: UInt64Value }
    | { $case: "float64"; float64: Float64Value }
    | { $case: "string"; string: StringValue }
    | { $case: "bytes"; bytes: BytesValue }
    | { $case: "decimal"; decimal: DecimalValue }
    | { $case: "duration"; duration: Duration }
    | { $case: "timestamp"; timestamp: Date }
    | { $case: "uuid"; uuid: UuidValue }
    | { $case: "array"; array: Array }
    | { $case: "object"; object: Object }
    | { $case: "geometry"; geometry: Geometry }
    | { $case: "recordId"; recordId: RecordId }
    | { $case: "file"; file: File }
    | undefined;
}

/** ID type. */
export interface Id {
  id?:
    | { $case: "int64"; int64: Int64Value }
    | { $case: "string"; string: StringValue }
    | { $case: "uuid"; uuid: UuidValue }
    | { $case: "array"; array: Array }
    | undefined;
}

function createBaseNullValue(): NullValue {
  return {};
}

export const NullValue: MessageFns<NullValue> = {
  encode(_: NullValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NullValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNullValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NullValue {
    return {};
  },

  toJSON(_: NullValue): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NullValue>, I>>(base?: I): NullValue {
    return NullValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NullValue>, I>>(_: I): NullValue {
    const message = createBaseNullValue();
    return message;
  },
};

function createBaseBoolValue(): BoolValue {
  return { value: false };
}

export const BoolValue: MessageFns<BoolValue> = {
  encode(message: BoolValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== false) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoolValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoolValue {
    return { value: isSet(object.value) ? globalThis.Boolean(object.value) : false };
  },

  toJSON(message: BoolValue): unknown {
    const obj: any = {};
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BoolValue>, I>>(base?: I): BoolValue {
    return BoolValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BoolValue>, I>>(object: I): BoolValue {
    const message = createBaseBoolValue();
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseInt64Value(): Int64Value {
  return { value: 0n };
}

export const Int64Value: MessageFns<Int64Value> = {
  encode(message: Int64Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0n) {
      if (BigInt.asIntN(64, message.value) !== message.value) {
        throw new globalThis.Error("value provided for field message.value of type int64 too large");
      }
      writer.uint32(8).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64Value {
    return { value: isSet(object.value) ? BigInt(object.value) : 0n };
  },

  toJSON(message: Int64Value): unknown {
    const obj: any = {};
    if (message.value !== 0n) {
      obj.value = message.value.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Int64Value>, I>>(base?: I): Int64Value {
    return Int64Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Int64Value>, I>>(object: I): Int64Value {
    const message = createBaseInt64Value();
    message.value = object.value ?? 0n;
    return message;
  },
};

function createBaseUInt64Value(): UInt64Value {
  return { value: 0n };
}

export const UInt64Value: MessageFns<UInt64Value> = {
  encode(message: UInt64Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0n) {
      if (BigInt.asUintN(64, message.value) !== message.value) {
        throw new globalThis.Error("value provided for field message.value of type uint64 too large");
      }
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64Value {
    return { value: isSet(object.value) ? BigInt(object.value) : 0n };
  },

  toJSON(message: UInt64Value): unknown {
    const obj: any = {};
    if (message.value !== 0n) {
      obj.value = message.value.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UInt64Value>, I>>(base?: I): UInt64Value {
    return UInt64Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UInt64Value>, I>>(object: I): UInt64Value {
    const message = createBaseUInt64Value();
    message.value = object.value ?? 0n;
    return message;
  },
};

function createBaseFloat64Value(): Float64Value {
  return { value: 0 };
}

export const Float64Value: MessageFns<Float64Value> = {
  encode(message: Float64Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Float64Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloat64Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Float64Value {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: Float64Value): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Float64Value>, I>>(base?: I): Float64Value {
    return Float64Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Float64Value>, I>>(object: I): Float64Value {
    const message = createBaseFloat64Value();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseStringValue(): StringValue {
  return { value: "" };
}

export const StringValue: MessageFns<StringValue> = {
  encode(message: StringValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: StringValue): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StringValue>, I>>(base?: I): StringValue {
    return StringValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StringValue>, I>>(object: I): StringValue {
    const message = createBaseStringValue();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBytesValue(): BytesValue {
  return { value: new Uint8Array(0) };
}

export const BytesValue: MessageFns<BytesValue> = {
  encode(message: BytesValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BytesValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBytesValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BytesValue {
    return { value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0) };
  },

  toJSON(message: BytesValue): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BytesValue>, I>>(base?: I): BytesValue {
    return BytesValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BytesValue>, I>>(object: I): BytesValue {
    const message = createBaseBytesValue();
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDecimalValue(): DecimalValue {
  return { value: "" };
}

export const DecimalValue: MessageFns<DecimalValue> = {
  encode(message: DecimalValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecimalValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecimalValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecimalValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: DecimalValue): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecimalValue>, I>>(base?: I): DecimalValue {
    return DecimalValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecimalValue>, I>>(object: I): DecimalValue {
    const message = createBaseDecimalValue();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUuidValue(): UuidValue {
  return { value: "" };
}

export const UuidValue: MessageFns<UuidValue> = {
  encode(message: UuidValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UuidValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUuidValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UuidValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: UuidValue): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UuidValue>, I>>(base?: I): UuidValue {
    return UuidValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UuidValue>, I>>(object: I): UuidValue {
    const message = createBaseUuidValue();
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePoint(): Point {
  return { x: 0, y: 0 };
}

export const Point: MessageFns<Point> = {
  encode(message: Point, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Point): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point>, I>>(base?: I): Point {
    return Point.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point>, I>>(object: I): Point {
    const message = createBasePoint();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseLineString(): LineString {
  return { points: [] };
}

export const LineString: MessageFns<LineString> = {
  encode(message: LineString, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.points) {
      Point.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineString {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.points.push(Point.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineString {
    return { points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Point.fromJSON(e)) : [] };
  },

  toJSON(message: LineString): unknown {
    const obj: any = {};
    if (message.points?.length) {
      obj.points = message.points.map((e) => Point.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LineString>, I>>(base?: I): LineString {
    return LineString.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LineString>, I>>(object: I): LineString {
    const message = createBaseLineString();
    message.points = object.points?.map((e) => Point.fromPartial(e)) || [];
    return message;
  },
};

function createBasePolygon(): Polygon {
  return { exterior: undefined, interiors: [] };
}

export const Polygon: MessageFns<Polygon> = {
  encode(message: Polygon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exterior !== undefined) {
      LineString.encode(message.exterior, writer.uint32(10).fork()).join();
    }
    for (const v of message.interiors) {
      LineString.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Polygon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exterior = LineString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.interiors.push(LineString.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Polygon {
    return {
      exterior: isSet(object.exterior) ? LineString.fromJSON(object.exterior) : undefined,
      interiors: globalThis.Array.isArray(object?.interiors)
        ? object.interiors.map((e: any) => LineString.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Polygon): unknown {
    const obj: any = {};
    if (message.exterior !== undefined) {
      obj.exterior = LineString.toJSON(message.exterior);
    }
    if (message.interiors?.length) {
      obj.interiors = message.interiors.map((e) => LineString.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Polygon>, I>>(base?: I): Polygon {
    return Polygon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Polygon>, I>>(object: I): Polygon {
    const message = createBasePolygon();
    message.exterior = (object.exterior !== undefined && object.exterior !== null)
      ? LineString.fromPartial(object.exterior)
      : undefined;
    message.interiors = object.interiors?.map((e) => LineString.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiPoint(): MultiPoint {
  return { points: [] };
}

export const MultiPoint: MessageFns<MultiPoint> = {
  encode(message: MultiPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.points) {
      Point.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.points.push(Point.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiPoint {
    return { points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Point.fromJSON(e)) : [] };
  },

  toJSON(message: MultiPoint): unknown {
    const obj: any = {};
    if (message.points?.length) {
      obj.points = message.points.map((e) => Point.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiPoint>, I>>(base?: I): MultiPoint {
    return MultiPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiPoint>, I>>(object: I): MultiPoint {
    const message = createBaseMultiPoint();
    message.points = object.points?.map((e) => Point.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiLineString(): MultiLineString {
  return { lines: [] };
}

export const MultiLineString: MessageFns<MultiLineString> = {
  encode(message: MultiLineString, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lines) {
      LineString.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLineString {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLineString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lines.push(LineString.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiLineString {
    return {
      lines: globalThis.Array.isArray(object?.lines) ? object.lines.map((e: any) => LineString.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiLineString): unknown {
    const obj: any = {};
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => LineString.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiLineString>, I>>(base?: I): MultiLineString {
    return MultiLineString.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLineString>, I>>(object: I): MultiLineString {
    const message = createBaseMultiLineString();
    message.lines = object.lines?.map((e) => LineString.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiPolygon(): MultiPolygon {
  return { polygons: [] };
}

export const MultiPolygon: MessageFns<MultiPolygon> = {
  encode(message: MultiPolygon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.polygons) {
      Polygon.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiPolygon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiPolygon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.polygons.push(Polygon.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiPolygon {
    return {
      polygons: globalThis.Array.isArray(object?.polygons) ? object.polygons.map((e: any) => Polygon.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiPolygon): unknown {
    const obj: any = {};
    if (message.polygons?.length) {
      obj.polygons = message.polygons.map((e) => Polygon.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiPolygon>, I>>(base?: I): MultiPolygon {
    return MultiPolygon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiPolygon>, I>>(object: I): MultiPolygon {
    const message = createBaseMultiPolygon();
    message.polygons = object.polygons?.map((e) => Polygon.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGeometryCollection(): GeometryCollection {
  return { geometries: [] };
}

export const GeometryCollection: MessageFns<GeometryCollection> = {
  encode(message: GeometryCollection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.geometries) {
      Geometry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeometryCollection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeometryCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.geometries.push(Geometry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeometryCollection {
    return {
      geometries: globalThis.Array.isArray(object?.geometries)
        ? object.geometries.map((e: any) => Geometry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GeometryCollection): unknown {
    const obj: any = {};
    if (message.geometries?.length) {
      obj.geometries = message.geometries.map((e) => Geometry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeometryCollection>, I>>(base?: I): GeometryCollection {
    return GeometryCollection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeometryCollection>, I>>(object: I): GeometryCollection {
    const message = createBaseGeometryCollection();
    message.geometries = object.geometries?.map((e) => Geometry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGeometry(): Geometry {
  return { geometry: undefined };
}

export const Geometry: MessageFns<Geometry> = {
  encode(message: Geometry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.geometry?.$case) {
      case "point":
        Point.encode(message.geometry.point, writer.uint32(10).fork()).join();
        break;
      case "lineString":
        LineString.encode(message.geometry.lineString, writer.uint32(18).fork()).join();
        break;
      case "polygon":
        Polygon.encode(message.geometry.polygon, writer.uint32(26).fork()).join();
        break;
      case "multiPoint":
        MultiPoint.encode(message.geometry.multiPoint, writer.uint32(34).fork()).join();
        break;
      case "multiLineString":
        MultiLineString.encode(message.geometry.multiLineString, writer.uint32(42).fork()).join();
        break;
      case "multiPolygon":
        MultiPolygon.encode(message.geometry.multiPolygon, writer.uint32(50).fork()).join();
        break;
      case "collection":
        GeometryCollection.encode(message.geometry.collection, writer.uint32(58).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Geometry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeometry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.geometry = { $case: "point", point: Point.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.geometry = { $case: "lineString", lineString: LineString.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.geometry = { $case: "polygon", polygon: Polygon.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.geometry = { $case: "multiPoint", multiPoint: MultiPoint.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.geometry = {
            $case: "multiLineString",
            multiLineString: MultiLineString.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.geometry = { $case: "multiPolygon", multiPolygon: MultiPolygon.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.geometry = { $case: "collection", collection: GeometryCollection.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Geometry {
    return {
      geometry: isSet(object.point)
        ? { $case: "point", point: Point.fromJSON(object.point) }
        : isSet(object.lineString)
        ? { $case: "lineString", lineString: LineString.fromJSON(object.lineString) }
        : isSet(object.polygon)
        ? { $case: "polygon", polygon: Polygon.fromJSON(object.polygon) }
        : isSet(object.multiPoint)
        ? { $case: "multiPoint", multiPoint: MultiPoint.fromJSON(object.multiPoint) }
        : isSet(object.multiLineString)
        ? { $case: "multiLineString", multiLineString: MultiLineString.fromJSON(object.multiLineString) }
        : isSet(object.multiPolygon)
        ? { $case: "multiPolygon", multiPolygon: MultiPolygon.fromJSON(object.multiPolygon) }
        : isSet(object.collection)
        ? { $case: "collection", collection: GeometryCollection.fromJSON(object.collection) }
        : undefined,
    };
  },

  toJSON(message: Geometry): unknown {
    const obj: any = {};
    if (message.geometry?.$case === "point") {
      obj.point = Point.toJSON(message.geometry.point);
    } else if (message.geometry?.$case === "lineString") {
      obj.lineString = LineString.toJSON(message.geometry.lineString);
    } else if (message.geometry?.$case === "polygon") {
      obj.polygon = Polygon.toJSON(message.geometry.polygon);
    } else if (message.geometry?.$case === "multiPoint") {
      obj.multiPoint = MultiPoint.toJSON(message.geometry.multiPoint);
    } else if (message.geometry?.$case === "multiLineString") {
      obj.multiLineString = MultiLineString.toJSON(message.geometry.multiLineString);
    } else if (message.geometry?.$case === "multiPolygon") {
      obj.multiPolygon = MultiPolygon.toJSON(message.geometry.multiPolygon);
    } else if (message.geometry?.$case === "collection") {
      obj.collection = GeometryCollection.toJSON(message.geometry.collection);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Geometry>, I>>(base?: I): Geometry {
    return Geometry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Geometry>, I>>(object: I): Geometry {
    const message = createBaseGeometry();
    switch (object.geometry?.$case) {
      case "point": {
        if (object.geometry?.point !== undefined && object.geometry?.point !== null) {
          message.geometry = { $case: "point", point: Point.fromPartial(object.geometry.point) };
        }
        break;
      }
      case "lineString": {
        if (object.geometry?.lineString !== undefined && object.geometry?.lineString !== null) {
          message.geometry = { $case: "lineString", lineString: LineString.fromPartial(object.geometry.lineString) };
        }
        break;
      }
      case "polygon": {
        if (object.geometry?.polygon !== undefined && object.geometry?.polygon !== null) {
          message.geometry = { $case: "polygon", polygon: Polygon.fromPartial(object.geometry.polygon) };
        }
        break;
      }
      case "multiPoint": {
        if (object.geometry?.multiPoint !== undefined && object.geometry?.multiPoint !== null) {
          message.geometry = { $case: "multiPoint", multiPoint: MultiPoint.fromPartial(object.geometry.multiPoint) };
        }
        break;
      }
      case "multiLineString": {
        if (object.geometry?.multiLineString !== undefined && object.geometry?.multiLineString !== null) {
          message.geometry = {
            $case: "multiLineString",
            multiLineString: MultiLineString.fromPartial(object.geometry.multiLineString),
          };
        }
        break;
      }
      case "multiPolygon": {
        if (object.geometry?.multiPolygon !== undefined && object.geometry?.multiPolygon !== null) {
          message.geometry = {
            $case: "multiPolygon",
            multiPolygon: MultiPolygon.fromPartial(object.geometry.multiPolygon),
          };
        }
        break;
      }
      case "collection": {
        if (object.geometry?.collection !== undefined && object.geometry?.collection !== null) {
          message.geometry = {
            $case: "collection",
            collection: GeometryCollection.fromPartial(object.geometry.collection),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseRecordId(): RecordId {
  return { table: "", id: undefined };
}

export const RecordId: MessageFns<RecordId> = {
  encode(message: RecordId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    if (message.id !== undefined) {
      Id.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecordId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = Id.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecordId {
    return {
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      id: isSet(object.id) ? Id.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: RecordId): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.id !== undefined) {
      obj.id = Id.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecordId>, I>>(base?: I): RecordId {
    return RecordId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecordId>, I>>(object: I): RecordId {
    const message = createBaseRecordId();
    message.table = object.table ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Id.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseFile(): File {
  return { bucket: "", key: "" };
}

export const File: MessageFns<File> = {
  encode(message: File, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): File {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): File {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: File): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<File>, I>>(base?: I): File {
    return File.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<File>, I>>(object: I): File {
    const message = createBaseFile();
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseArray(): Array {
  return { values: [] };
}

export const Array: MessageFns<Array> = {
  encode(message: Array, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Array {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Array {
    return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Value.fromJSON(e)) : [] };
  },

  toJSON(message: Array): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Array>, I>>(base?: I): Array {
    return Array.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Array>, I>>(object: I): Array {
    const message = createBaseArray();
    message.values = object.values?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseObject(): Object {
  return { items: {} };
}

export const Object: MessageFns<Object> = {
  encode(message: Object, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.items).forEach(([key, value]) => {
      Object_ItemsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Object {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Object_ItemsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.items[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Object {
    return {
      items: isObject(object.items)
        ? Object.entries(object.items).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Object): unknown {
    const obj: any = {};
    if (message.items) {
      const entries = Object.entries(message.items);
      if (entries.length > 0) {
        obj.items = {};
        entries.forEach(([k, v]) => {
          obj.items[k] = Value.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Object>, I>>(base?: I): Object {
    return Object.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Object>, I>>(object: I): Object {
    const message = createBaseObject();
    message.items = Object.entries(object.items ?? {}).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseObject_ItemsEntry(): Object_ItemsEntry {
  return { key: "", value: undefined };
}

export const Object_ItemsEntry: MessageFns<Object_ItemsEntry> = {
  encode(message: Object_ItemsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Object_ItemsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObject_ItemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Object_ItemsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Object_ItemsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Object_ItemsEntry>, I>>(base?: I): Object_ItemsEntry {
    return Object_ItemsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Object_ItemsEntry>, I>>(object: I): Object_ItemsEntry {
    const message = createBaseObject_ItemsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseValue(): Value {
  return { value: undefined };
}

export const Value: MessageFns<Value> = {
  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.value?.$case) {
      case "null":
        NullValue.encode(message.value.null, writer.uint32(10).fork()).join();
        break;
      case "bool":
        BoolValue.encode(message.value.bool, writer.uint32(18).fork()).join();
        break;
      case "int64":
        Int64Value.encode(message.value.int64, writer.uint32(26).fork()).join();
        break;
      case "uint64":
        UInt64Value.encode(message.value.uint64, writer.uint32(34).fork()).join();
        break;
      case "float64":
        Float64Value.encode(message.value.float64, writer.uint32(42).fork()).join();
        break;
      case "string":
        StringValue.encode(message.value.string, writer.uint32(50).fork()).join();
        break;
      case "bytes":
        BytesValue.encode(message.value.bytes, writer.uint32(58).fork()).join();
        break;
      case "decimal":
        DecimalValue.encode(message.value.decimal, writer.uint32(66).fork()).join();
        break;
      case "duration":
        Duration.encode(message.value.duration, writer.uint32(74).fork()).join();
        break;
      case "timestamp":
        Timestamp.encode(toTimestamp(message.value.timestamp), writer.uint32(82).fork()).join();
        break;
      case "uuid":
        UuidValue.encode(message.value.uuid, writer.uint32(90).fork()).join();
        break;
      case "array":
        Array.encode(message.value.array, writer.uint32(98).fork()).join();
        break;
      case "object":
        Object.encode(message.value.object, writer.uint32(106).fork()).join();
        break;
      case "geometry":
        Geometry.encode(message.value.geometry, writer.uint32(114).fork()).join();
        break;
      case "recordId":
        RecordId.encode(message.value.recordId, writer.uint32(122).fork()).join();
        break;
      case "file":
        File.encode(message.value.file, writer.uint32(130).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = { $case: "null", null: NullValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = { $case: "bool", bool: BoolValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = { $case: "int64", int64: Int64Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = { $case: "uint64", uint64: UInt64Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.value = { $case: "float64", float64: Float64Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.value = { $case: "string", string: StringValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.value = { $case: "bytes", bytes: BytesValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.value = { $case: "decimal", decimal: DecimalValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.value = { $case: "duration", duration: Duration.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.value = { $case: "timestamp", timestamp: fromTimestamp(Timestamp.decode(reader, reader.uint32())) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.value = { $case: "uuid", uuid: UuidValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.value = { $case: "array", array: Array.decode(reader, reader.uint32()) };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.value = { $case: "object", object: Object.decode(reader, reader.uint32()) };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.value = { $case: "geometry", geometry: Geometry.decode(reader, reader.uint32()) };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.value = { $case: "recordId", recordId: RecordId.decode(reader, reader.uint32()) };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.value = { $case: "file", file: File.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      value: isSet(object.null)
        ? { $case: "null", null: NullValue.fromJSON(object.null) }
        : isSet(object.bool)
        ? { $case: "bool", bool: BoolValue.fromJSON(object.bool) }
        : isSet(object.int64)
        ? { $case: "int64", int64: Int64Value.fromJSON(object.int64) }
        : isSet(object.uint64)
        ? { $case: "uint64", uint64: UInt64Value.fromJSON(object.uint64) }
        : isSet(object.float64)
        ? { $case: "float64", float64: Float64Value.fromJSON(object.float64) }
        : isSet(object.string)
        ? { $case: "string", string: StringValue.fromJSON(object.string) }
        : isSet(object.bytes)
        ? { $case: "bytes", bytes: BytesValue.fromJSON(object.bytes) }
        : isSet(object.decimal)
        ? { $case: "decimal", decimal: DecimalValue.fromJSON(object.decimal) }
        : isSet(object.duration)
        ? { $case: "duration", duration: Duration.fromJSON(object.duration) }
        : isSet(object.timestamp)
        ? { $case: "timestamp", timestamp: fromJsonTimestamp(object.timestamp) }
        : isSet(object.uuid)
        ? { $case: "uuid", uuid: UuidValue.fromJSON(object.uuid) }
        : isSet(object.array)
        ? { $case: "array", array: Array.fromJSON(object.array) }
        : isSet(object.object)
        ? { $case: "object", object: Object.fromJSON(object.object) }
        : isSet(object.geometry)
        ? { $case: "geometry", geometry: Geometry.fromJSON(object.geometry) }
        : isSet(object.recordId)
        ? { $case: "recordId", recordId: RecordId.fromJSON(object.recordId) }
        : isSet(object.file)
        ? { $case: "file", file: File.fromJSON(object.file) }
        : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.value?.$case === "null") {
      obj.null = NullValue.toJSON(message.value.null);
    } else if (message.value?.$case === "bool") {
      obj.bool = BoolValue.toJSON(message.value.bool);
    } else if (message.value?.$case === "int64") {
      obj.int64 = Int64Value.toJSON(message.value.int64);
    } else if (message.value?.$case === "uint64") {
      obj.uint64 = UInt64Value.toJSON(message.value.uint64);
    } else if (message.value?.$case === "float64") {
      obj.float64 = Float64Value.toJSON(message.value.float64);
    } else if (message.value?.$case === "string") {
      obj.string = StringValue.toJSON(message.value.string);
    } else if (message.value?.$case === "bytes") {
      obj.bytes = BytesValue.toJSON(message.value.bytes);
    } else if (message.value?.$case === "decimal") {
      obj.decimal = DecimalValue.toJSON(message.value.decimal);
    } else if (message.value?.$case === "duration") {
      obj.duration = Duration.toJSON(message.value.duration);
    } else if (message.value?.$case === "timestamp") {
      obj.timestamp = message.value.timestamp.toISOString();
    } else if (message.value?.$case === "uuid") {
      obj.uuid = UuidValue.toJSON(message.value.uuid);
    } else if (message.value?.$case === "array") {
      obj.array = Array.toJSON(message.value.array);
    } else if (message.value?.$case === "object") {
      obj.object = Object.toJSON(message.value.object);
    } else if (message.value?.$case === "geometry") {
      obj.geometry = Geometry.toJSON(message.value.geometry);
    } else if (message.value?.$case === "recordId") {
      obj.recordId = RecordId.toJSON(message.value.recordId);
    } else if (message.value?.$case === "file") {
      obj.file = File.toJSON(message.value.file);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {
    return Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {
    const message = createBaseValue();
    switch (object.value?.$case) {
      case "null": {
        if (object.value?.null !== undefined && object.value?.null !== null) {
          message.value = { $case: "null", null: NullValue.fromPartial(object.value.null) };
        }
        break;
      }
      case "bool": {
        if (object.value?.bool !== undefined && object.value?.bool !== null) {
          message.value = { $case: "bool", bool: BoolValue.fromPartial(object.value.bool) };
        }
        break;
      }
      case "int64": {
        if (object.value?.int64 !== undefined && object.value?.int64 !== null) {
          message.value = { $case: "int64", int64: Int64Value.fromPartial(object.value.int64) };
        }
        break;
      }
      case "uint64": {
        if (object.value?.uint64 !== undefined && object.value?.uint64 !== null) {
          message.value = { $case: "uint64", uint64: UInt64Value.fromPartial(object.value.uint64) };
        }
        break;
      }
      case "float64": {
        if (object.value?.float64 !== undefined && object.value?.float64 !== null) {
          message.value = { $case: "float64", float64: Float64Value.fromPartial(object.value.float64) };
        }
        break;
      }
      case "string": {
        if (object.value?.string !== undefined && object.value?.string !== null) {
          message.value = { $case: "string", string: StringValue.fromPartial(object.value.string) };
        }
        break;
      }
      case "bytes": {
        if (object.value?.bytes !== undefined && object.value?.bytes !== null) {
          message.value = { $case: "bytes", bytes: BytesValue.fromPartial(object.value.bytes) };
        }
        break;
      }
      case "decimal": {
        if (object.value?.decimal !== undefined && object.value?.decimal !== null) {
          message.value = { $case: "decimal", decimal: DecimalValue.fromPartial(object.value.decimal) };
        }
        break;
      }
      case "duration": {
        if (object.value?.duration !== undefined && object.value?.duration !== null) {
          message.value = { $case: "duration", duration: Duration.fromPartial(object.value.duration) };
        }
        break;
      }
      case "timestamp": {
        if (object.value?.timestamp !== undefined && object.value?.timestamp !== null) {
          message.value = { $case: "timestamp", timestamp: object.value.timestamp };
        }
        break;
      }
      case "uuid": {
        if (object.value?.uuid !== undefined && object.value?.uuid !== null) {
          message.value = { $case: "uuid", uuid: UuidValue.fromPartial(object.value.uuid) };
        }
        break;
      }
      case "array": {
        if (object.value?.array !== undefined && object.value?.array !== null) {
          message.value = { $case: "array", array: Array.fromPartial(object.value.array) };
        }
        break;
      }
      case "object": {
        if (object.value?.object !== undefined && object.value?.object !== null) {
          message.value = { $case: "object", object: Object.fromPartial(object.value.object) };
        }
        break;
      }
      case "geometry": {
        if (object.value?.geometry !== undefined && object.value?.geometry !== null) {
          message.value = { $case: "geometry", geometry: Geometry.fromPartial(object.value.geometry) };
        }
        break;
      }
      case "recordId": {
        if (object.value?.recordId !== undefined && object.value?.recordId !== null) {
          message.value = { $case: "recordId", recordId: RecordId.fromPartial(object.value.recordId) };
        }
        break;
      }
      case "file": {
        if (object.value?.file !== undefined && object.value?.file !== null) {
          message.value = { $case: "file", file: File.fromPartial(object.value.file) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseId(): Id {
  return { id: undefined };
}

export const Id: MessageFns<Id> = {
  encode(message: Id, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.id?.$case) {
      case "int64":
        Int64Value.encode(message.id.int64, writer.uint32(10).fork()).join();
        break;
      case "string":
        StringValue.encode(message.id.string, writer.uint32(18).fork()).join();
        break;
      case "uuid":
        UuidValue.encode(message.id.uuid, writer.uint32(26).fork()).join();
        break;
      case "array":
        Array.encode(message.id.array, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Id {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = { $case: "int64", int64: Int64Value.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = { $case: "string", string: StringValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = { $case: "uuid", uuid: UuidValue.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = { $case: "array", array: Array.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Id {
    return {
      id: isSet(object.int64)
        ? { $case: "int64", int64: Int64Value.fromJSON(object.int64) }
        : isSet(object.string)
        ? { $case: "string", string: StringValue.fromJSON(object.string) }
        : isSet(object.uuid)
        ? { $case: "uuid", uuid: UuidValue.fromJSON(object.uuid) }
        : isSet(object.array)
        ? { $case: "array", array: Array.fromJSON(object.array) }
        : undefined,
    };
  },

  toJSON(message: Id): unknown {
    const obj: any = {};
    if (message.id?.$case === "int64") {
      obj.int64 = Int64Value.toJSON(message.id.int64);
    } else if (message.id?.$case === "string") {
      obj.string = StringValue.toJSON(message.id.string);
    } else if (message.id?.$case === "uuid") {
      obj.uuid = UuidValue.toJSON(message.id.uuid);
    } else if (message.id?.$case === "array") {
      obj.array = Array.toJSON(message.id.array);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Id>, I>>(base?: I): Id {
    return Id.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Id>, I>>(object: I): Id {
    const message = createBaseId();
    switch (object.id?.$case) {
      case "int64": {
        if (object.id?.int64 !== undefined && object.id?.int64 !== null) {
          message.id = { $case: "int64", int64: Int64Value.fromPartial(object.id.int64) };
        }
        break;
      }
      case "string": {
        if (object.id?.string !== undefined && object.id?.string !== null) {
          message.id = { $case: "string", string: StringValue.fromPartial(object.id.string) };
        }
        break;
      }
      case "uuid": {
        if (object.id?.uuid !== undefined && object.id?.uuid !== null) {
          message.id = { $case: "uuid", uuid: UuidValue.fromPartial(object.id.uuid) };
        }
        break;
      }
      case "array": {
        if (object.id?.array !== undefined && object.id?.array !== null) {
          message.id = { $case: "array", array: Array.fromPartial(object.id.array) };
        }
        break;
      }
    }
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds.toString()) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
