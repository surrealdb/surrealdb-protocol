// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum KindOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind<'a> {
  type Inner = Kind<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind<'a> {
  pub const VT_KIND_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_KIND: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KindArgs
  ) -> flatbuffers::WIPOffset<Kind<'bldr>> {
    let mut builder = KindBuilder::new(_fbb);
    if let Some(x) = args.kind { builder.add_kind(x); }
    builder.add_kind_type(args.kind_type);
    builder.finish()
  }


  #[inline]
  pub fn kind_type(&self) -> KindType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindType>(Kind::VT_KIND_TYPE, Some(KindType::NONE)).unwrap()}
  }
  #[inline]
  pub fn kind(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Kind::VT_KIND, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_any(&self) -> Option<AnyKind<'a>> {
    if self.kind_type() == KindType::Any {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AnyKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_null(&self) -> Option<NullKind<'a>> {
    if self.kind_type() == KindType::Null {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NullKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_bool(&self) -> Option<BoolKind<'a>> {
    if self.kind_type() == KindType::Bool {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BoolKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_bytes(&self) -> Option<BytesKind<'a>> {
    if self.kind_type() == KindType::Bytes {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BytesKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_datetime(&self) -> Option<DatetimeKind<'a>> {
    if self.kind_type() == KindType::Datetime {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DatetimeKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_decimal(&self) -> Option<DecimalKind<'a>> {
    if self.kind_type() == KindType::Decimal {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DecimalKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_duration(&self) -> Option<DurationKind<'a>> {
    if self.kind_type() == KindType::Duration {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DurationKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_float(&self) -> Option<FloatKind<'a>> {
    if self.kind_type() == KindType::Float {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FloatKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_int(&self) -> Option<IntKind<'a>> {
    if self.kind_type() == KindType::Int {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { IntKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_number(&self) -> Option<NumberKind<'a>> {
    if self.kind_type() == KindType::Number {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NumberKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_object(&self) -> Option<ObjectKind<'a>> {
    if self.kind_type() == KindType::Object {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ObjectKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_point(&self) -> Option<PointKind<'a>> {
    if self.kind_type() == KindType::Point {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PointKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_string(&self) -> Option<StringKind<'a>> {
    if self.kind_type() == KindType::String {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StringKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_uuid(&self) -> Option<UuidKind<'a>> {
    if self.kind_type() == KindType::Uuid {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UuidKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_regex(&self) -> Option<RegexKind<'a>> {
    if self.kind_type() == KindType::Regex {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RegexKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_record(&self) -> Option<RecordKind<'a>> {
    if self.kind_type() == KindType::Record {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RecordKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_geometry(&self) -> Option<GeometryKind<'a>> {
    if self.kind_type() == KindType::Geometry {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GeometryKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_option(&self) -> Option<OptionKind<'a>> {
    if self.kind_type() == KindType::Option {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { OptionKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_either(&self) -> Option<EitherKind<'a>> {
    if self.kind_type() == KindType::Either {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { EitherKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_set(&self) -> Option<SetKind<'a>> {
    if self.kind_type() == KindType::Set {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SetKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_array(&self) -> Option<ArrayKind<'a>> {
    if self.kind_type() == KindType::Array {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ArrayKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_function(&self) -> Option<FunctionKind<'a>> {
    if self.kind_type() == KindType::Function {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FunctionKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_range(&self) -> Option<RangeKind<'a>> {
    if self.kind_type() == KindType::Range {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RangeKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_literal(&self) -> Option<LiteralKind<'a>> {
    if self.kind_type() == KindType::Literal {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LiteralKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn kind_as_file(&self) -> Option<FileKind<'a>> {
    if self.kind_type() == KindType::File {
      self.kind().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FileKind::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Kind<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<KindType, _>("kind_type", Self::VT_KIND_TYPE, "kind", Self::VT_KIND, false, |key, v, pos| {
        match key {
          KindType::Any => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AnyKind>>("KindType::Any", pos),
          KindType::Null => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NullKind>>("KindType::Null", pos),
          KindType::Bool => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BoolKind>>("KindType::Bool", pos),
          KindType::Bytes => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BytesKind>>("KindType::Bytes", pos),
          KindType::Datetime => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DatetimeKind>>("KindType::Datetime", pos),
          KindType::Decimal => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DecimalKind>>("KindType::Decimal", pos),
          KindType::Duration => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationKind>>("KindType::Duration", pos),
          KindType::Float => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatKind>>("KindType::Float", pos),
          KindType::Int => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntKind>>("KindType::Int", pos),
          KindType::Number => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NumberKind>>("KindType::Number", pos),
          KindType::Object => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObjectKind>>("KindType::Object", pos),
          KindType::Point => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PointKind>>("KindType::Point", pos),
          KindType::String => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringKind>>("KindType::String", pos),
          KindType::Uuid => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UuidKind>>("KindType::Uuid", pos),
          KindType::Regex => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexKind>>("KindType::Regex", pos),
          KindType::Record => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RecordKind>>("KindType::Record", pos),
          KindType::Geometry => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GeometryKind>>("KindType::Geometry", pos),
          KindType::Option => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OptionKind>>("KindType::Option", pos),
          KindType::Either => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EitherKind>>("KindType::Either", pos),
          KindType::Set => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SetKind>>("KindType::Set", pos),
          KindType::Array => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayKind>>("KindType::Array", pos),
          KindType::Function => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionKind>>("KindType::Function", pos),
          KindType::Range => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RangeKind>>("KindType::Range", pos),
          KindType::Literal => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LiteralKind>>("KindType::Literal", pos),
          KindType::File => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FileKind>>("KindType::File", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct KindArgs {
    pub kind_type: KindType,
    pub kind: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for KindArgs {
  #[inline]
  fn default() -> Self {
    KindArgs {
      kind_type: KindType::NONE,
      kind: None,
    }
  }
}

pub struct KindBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KindBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_kind_type(&mut self, kind_type: KindType) {
    self.fbb_.push_slot::<KindType>(Kind::VT_KIND_TYPE, kind_type, KindType::NONE);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind::VT_KIND, kind);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KindBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KindBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind");
      ds.field("kind_type", &self.kind_type());
      match self.kind_type() {
        KindType::Any => {
          if let Some(x) = self.kind_as_any() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Null => {
          if let Some(x) = self.kind_as_null() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Bool => {
          if let Some(x) = self.kind_as_bool() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Bytes => {
          if let Some(x) = self.kind_as_bytes() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Datetime => {
          if let Some(x) = self.kind_as_datetime() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Decimal => {
          if let Some(x) = self.kind_as_decimal() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Duration => {
          if let Some(x) = self.kind_as_duration() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Float => {
          if let Some(x) = self.kind_as_float() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Int => {
          if let Some(x) = self.kind_as_int() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Number => {
          if let Some(x) = self.kind_as_number() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Object => {
          if let Some(x) = self.kind_as_object() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Point => {
          if let Some(x) = self.kind_as_point() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::String => {
          if let Some(x) = self.kind_as_string() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Uuid => {
          if let Some(x) = self.kind_as_uuid() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Regex => {
          if let Some(x) = self.kind_as_regex() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Record => {
          if let Some(x) = self.kind_as_record() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Geometry => {
          if let Some(x) = self.kind_as_geometry() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Option => {
          if let Some(x) = self.kind_as_option() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Either => {
          if let Some(x) = self.kind_as_either() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Set => {
          if let Some(x) = self.kind_as_set() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Array => {
          if let Some(x) = self.kind_as_array() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Function => {
          if let Some(x) = self.kind_as_function() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Range => {
          if let Some(x) = self.kind_as_range() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::Literal => {
          if let Some(x) = self.kind_as_literal() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        KindType::File => {
          if let Some(x) = self.kind_as_file() {
            ds.field("kind", &x)
          } else {
            ds.field("kind", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("kind", &x)
        },
      };
      ds.finish()
  }
}
