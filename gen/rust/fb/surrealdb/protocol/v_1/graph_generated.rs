// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum GraphOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Graph<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Graph<'a> {
  type Inner = Graph<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Graph<'a> {
  pub const VT_DIR: flatbuffers::VOffsetT = 4;
  pub const VT_EXPR: flatbuffers::VOffsetT = 6;
  pub const VT_WHAT: flatbuffers::VOffsetT = 8;
  pub const VT_COND: flatbuffers::VOffsetT = 10;
  pub const VT_SPLIT: flatbuffers::VOffsetT = 12;
  pub const VT_GROUP: flatbuffers::VOffsetT = 14;
  pub const VT_ORDER: flatbuffers::VOffsetT = 16;
  pub const VT_LIMIT: flatbuffers::VOffsetT = 18;
  pub const VT_START: flatbuffers::VOffsetT = 20;
  pub const VT_ALIAS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Graph { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GraphArgs<'args>
  ) -> flatbuffers::WIPOffset<Graph<'bldr>> {
    let mut builder = GraphBuilder::new(_fbb);
    if let Some(x) = args.start { builder.add_start(x); }
    if let Some(x) = args.limit { builder.add_limit(x); }
    if let Some(x) = args.alias { builder.add_alias(x); }
    if let Some(x) = args.order { builder.add_order(x); }
    if let Some(x) = args.group { builder.add_group(x); }
    if let Some(x) = args.split { builder.add_split(x); }
    if let Some(x) = args.cond { builder.add_cond(x); }
    if let Some(x) = args.what { builder.add_what(x); }
    if let Some(x) = args.expr { builder.add_expr(x); }
    builder.add_dir(args.dir);
    builder.finish()
  }


  #[inline]
  pub fn dir(&self) -> GraphDirection {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GraphDirection>(Graph::VT_DIR, Some(GraphDirection::In)).unwrap()}
  }
  #[inline]
  pub fn expr(&self) -> Option<Fields<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Fields>>(Graph::VT_EXPR, None)}
  }
  #[inline]
  pub fn what(&self) -> Option<GraphSubjects<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GraphSubjects>>(Graph::VT_WHAT, None)}
  }
  #[inline]
  pub fn cond(&self) -> Option<Value<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Value>>(Graph::VT_COND, None)}
  }
  #[inline]
  pub fn split(&self) -> Option<Splits<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Splits>>(Graph::VT_SPLIT, None)}
  }
  #[inline]
  pub fn group(&self) -> Option<Groups<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Groups>>(Graph::VT_GROUP, None)}
  }
  #[inline]
  pub fn order(&self) -> Option<OrderingSpec<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<OrderingSpec>>(Graph::VT_ORDER, None)}
  }
  #[inline]
  pub fn limit(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Graph::VT_LIMIT, None)}
  }
  #[inline]
  pub fn start(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Graph::VT_START, None)}
  }
  #[inline]
  pub fn alias(&self) -> Option<Idiom<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Idiom>>(Graph::VT_ALIAS, None)}
  }
}

impl flatbuffers::Verifiable for Graph<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GraphDirection>("dir", Self::VT_DIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Fields>>("expr", Self::VT_EXPR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GraphSubjects>>("what", Self::VT_WHAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Value>>("cond", Self::VT_COND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Splits>>("split", Self::VT_SPLIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Groups>>("group", Self::VT_GROUP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<OrderingSpec>>("order", Self::VT_ORDER, false)?
     .visit_field::<u64>("limit", Self::VT_LIMIT, false)?
     .visit_field::<u64>("start", Self::VT_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Idiom>>("alias", Self::VT_ALIAS, false)?
     .finish();
    Ok(())
  }
}
pub struct GraphArgs<'a> {
    pub dir: GraphDirection,
    pub expr: Option<flatbuffers::WIPOffset<Fields<'a>>>,
    pub what: Option<flatbuffers::WIPOffset<GraphSubjects<'a>>>,
    pub cond: Option<flatbuffers::WIPOffset<Value<'a>>>,
    pub split: Option<flatbuffers::WIPOffset<Splits<'a>>>,
    pub group: Option<flatbuffers::WIPOffset<Groups<'a>>>,
    pub order: Option<flatbuffers::WIPOffset<OrderingSpec<'a>>>,
    pub limit: Option<u64>,
    pub start: Option<u64>,
    pub alias: Option<flatbuffers::WIPOffset<Idiom<'a>>>,
}
impl<'a> Default for GraphArgs<'a> {
  #[inline]
  fn default() -> Self {
    GraphArgs {
      dir: GraphDirection::In,
      expr: None,
      what: None,
      cond: None,
      split: None,
      group: None,
      order: None,
      limit: None,
      start: None,
      alias: None,
    }
  }
}

pub struct GraphBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GraphBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dir(&mut self, dir: GraphDirection) {
    self.fbb_.push_slot::<GraphDirection>(Graph::VT_DIR, dir, GraphDirection::In);
  }
  #[inline]
  pub fn add_expr(&mut self, expr: flatbuffers::WIPOffset<Fields<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Fields>>(Graph::VT_EXPR, expr);
  }
  #[inline]
  pub fn add_what(&mut self, what: flatbuffers::WIPOffset<GraphSubjects<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GraphSubjects>>(Graph::VT_WHAT, what);
  }
  #[inline]
  pub fn add_cond(&mut self, cond: flatbuffers::WIPOffset<Value<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Value>>(Graph::VT_COND, cond);
  }
  #[inline]
  pub fn add_split(&mut self, split: flatbuffers::WIPOffset<Splits<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Splits>>(Graph::VT_SPLIT, split);
  }
  #[inline]
  pub fn add_group(&mut self, group: flatbuffers::WIPOffset<Groups<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Groups>>(Graph::VT_GROUP, group);
  }
  #[inline]
  pub fn add_order(&mut self, order: flatbuffers::WIPOffset<OrderingSpec<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<OrderingSpec>>(Graph::VT_ORDER, order);
  }
  #[inline]
  pub fn add_limit(&mut self, limit: u64) {
    self.fbb_.push_slot_always::<u64>(Graph::VT_LIMIT, limit);
  }
  #[inline]
  pub fn add_start(&mut self, start: u64) {
    self.fbb_.push_slot_always::<u64>(Graph::VT_START, start);
  }
  #[inline]
  pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<Idiom<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Idiom>>(Graph::VT_ALIAS, alias);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GraphBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GraphBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Graph<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Graph<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Graph");
      ds.field("dir", &self.dir());
      ds.field("expr", &self.expr());
      ds.field("what", &self.what());
      ds.field("cond", &self.cond());
      ds.field("split", &self.split());
      ds.field("group", &self.group());
      ds.field("order", &self.order());
      ds.field("limit", &self.limit());
      ds.field("start", &self.start());
      ds.field("alias", &self.alias());
      ds.finish()
  }
}
