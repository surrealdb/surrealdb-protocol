// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PART_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PART_TYPE: u8 = 16;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PART_TYPE: [PartType; 17] = [
  PartType::NONE,
  PartType::All,
  PartType::Flatten,
  PartType::Last,
  PartType::First,
  PartType::Start,
  PartType::Field,
  PartType::Index,
  PartType::Where,
  PartType::Graph,
  PartType::Value,
  PartType::Method,
  PartType::Destructure,
  PartType::Optional,
  PartType::Recurse,
  PartType::Doc,
  PartType::RepeatRecurse,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PartType(pub u8);
#[allow(non_upper_case_globals)]
impl PartType {
  pub const NONE: Self = Self(0);
  /// Represents `[*]`
  pub const All: Self = Self(1);
  /// Represents `...`
  pub const Flatten: Self = Self(2);
  /// Represents `[$]`
  pub const Last: Self = Self(3);
  /// Represents `[0]`
  pub const First: Self = Self(4);
  /// Represents `<start>`, which is the first part.
  pub const Start: Self = Self(5);
  /// Represents `start.<field>`
  pub const Field: Self = Self(6);
  /// Represents `[<index>]`
  pub const Index: Self = Self(7);
  /// Represents `[WHERE <value>]`
  pub const Where: Self = Self(8);
  /// Represents a graph traversal; e.g., `->`, `<-`, or `<->`
  pub const Graph: Self = Self(9);
  /// Represents a value, which can be a literal or an expression.
  pub const Value: Self = Self(10);
  /// Represents a method call, e.g., `a.b.c.<method>(args)`
  pub const Method: Self = Self(11);
  /// Represents a destructure operation, e.g., `a.b.c.{field1, field2}`
  pub const Destructure: Self = Self(12);
  /// Represents an optional part, e.g., `a.b.c?`
  pub const Optional: Self = Self(13);
  /// Represents a recursive operation.
  pub const Recurse: Self = Self(14);
  /// Represents a docuemnt, e.g., `@`
  pub const Doc: Self = Self(15);
  /// Represents a repeat operation, e.g., `.@`
  pub const RepeatRecurse: Self = Self(16);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 16;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::All,
    Self::Flatten,
    Self::Last,
    Self::First,
    Self::Start,
    Self::Field,
    Self::Index,
    Self::Where,
    Self::Graph,
    Self::Value,
    Self::Method,
    Self::Destructure,
    Self::Optional,
    Self::Recurse,
    Self::Doc,
    Self::RepeatRecurse,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::All => Some("All"),
      Self::Flatten => Some("Flatten"),
      Self::Last => Some("Last"),
      Self::First => Some("First"),
      Self::Start => Some("Start"),
      Self::Field => Some("Field"),
      Self::Index => Some("Index"),
      Self::Where => Some("Where"),
      Self::Graph => Some("Graph"),
      Self::Value => Some("Value"),
      Self::Method => Some("Method"),
      Self::Destructure => Some("Destructure"),
      Self::Optional => Some("Optional"),
      Self::Recurse => Some("Recurse"),
      Self::Doc => Some("Doc"),
      Self::RepeatRecurse => Some("RepeatRecurse"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PartType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PartType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PartType {
    type Output = PartType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PartType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PartType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PartType {}
pub struct PartTypeUnionTableOffset {}

