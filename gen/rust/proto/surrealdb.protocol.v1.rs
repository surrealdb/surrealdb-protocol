// @generated
// This file is @generated by prost-build.
/// Null value.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NullValue {
}
impl ::prost::Name for NullValue {
const NAME: &'static str = "NullValue";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.NullValue".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.NullValue".into() }}
/// Decimal value.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Decimal {
    #[prost(string, tag="1")]
    pub value: ::prost::alloc::string::String,
}
impl ::prost::Name for Decimal {
const NAME: &'static str = "Decimal";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Decimal".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Decimal".into() }}
/// UUID value.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uuid {
    #[prost(string, tag="1")]
    pub value: ::prost::alloc::string::String,
}
impl ::prost::Name for Uuid {
const NAME: &'static str = "Uuid";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Uuid".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Uuid".into() }}
/// Point type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Point {
    #[prost(double, tag="1")]
    pub x: f64,
    #[prost(double, tag="2")]
    pub y: f64,
}
impl ::prost::Name for Point {
const NAME: &'static str = "Point";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Point".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Point".into() }}
/// Line type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Line {
    #[prost(message, repeated, tag="1")]
    pub points: ::prost::alloc::vec::Vec<Point>,
}
impl ::prost::Name for Line {
const NAME: &'static str = "Line";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Line".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Line".into() }}
/// Polygon type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Polygon {
    /// Exterior ring.
    #[prost(message, optional, tag="1")]
    pub exterior: ::core::option::Option<Line>,
    /// Interior rings.
    #[prost(message, repeated, tag="2")]
    pub interiors: ::prost::alloc::vec::Vec<Line>,
}
impl ::prost::Name for Polygon {
const NAME: &'static str = "Polygon";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Polygon".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Polygon".into() }}
/// MultiPoint type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiPoint {
    #[prost(message, repeated, tag="1")]
    pub points: ::prost::alloc::vec::Vec<Point>,
}
impl ::prost::Name for MultiPoint {
const NAME: &'static str = "MultiPoint";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.MultiPoint".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.MultiPoint".into() }}
/// MultiLine type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiLine {
    #[prost(message, repeated, tag="1")]
    pub lines: ::prost::alloc::vec::Vec<Line>,
}
impl ::prost::Name for MultiLine {
const NAME: &'static str = "MultiLine";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.MultiLine".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.MultiLine".into() }}
/// MultiPolygon type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiPolygon {
    #[prost(message, repeated, tag="1")]
    pub polygons: ::prost::alloc::vec::Vec<Polygon>,
}
impl ::prost::Name for MultiPolygon {
const NAME: &'static str = "MultiPolygon";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.MultiPolygon".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.MultiPolygon".into() }}
/// GeometryCollection type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeometryCollection {
    #[prost(message, repeated, tag="1")]
    pub geometries: ::prost::alloc::vec::Vec<Geometry>,
}
impl ::prost::Name for GeometryCollection {
const NAME: &'static str = "GeometryCollection";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.GeometryCollection".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.GeometryCollection".into() }}
/// Generic geometry type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Geometry {
    #[prost(oneof="geometry::Geometry", tags="1, 2, 3, 4, 5, 6, 7")]
    #[serde(flatten)]
    pub geometry: ::core::option::Option<geometry::Geometry>,
}
/// Nested message and enum types in `Geometry`.
pub mod geometry {
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Geometry {
        #[prost(message, tag="1")]
        Point(super::Point),
        #[prost(message, tag="2")]
        Line(super::Line),
        #[prost(message, tag="3")]
        Polygon(super::Polygon),
        #[prost(message, tag="4")]
        MultiPoint(super::MultiPoint),
        #[prost(message, tag="5")]
        MultiLine(super::MultiLine),
        #[prost(message, tag="6")]
        MultiPolygon(super::MultiPolygon),
        #[prost(message, tag="7")]
        Collection(super::GeometryCollection),
    }
}
impl ::prost::Name for Geometry {
const NAME: &'static str = "Geometry";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Geometry".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Geometry".into() }}
/// Record ID type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordId {
    /// Table name.
    #[prost(string, tag="1")]
    pub table: ::prost::alloc::string::String,
    /// Record ID.
    #[prost(message, optional, tag="2")]
    pub id: ::core::option::Option<Id>,
}
impl ::prost::Name for RecordId {
const NAME: &'static str = "RecordId";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.RecordId".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.RecordId".into() }}
/// File type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct File {
    /// Bucket name.
    #[prost(string, tag="1")]
    pub bucket: ::prost::alloc::string::String,
    /// File key.
    #[prost(string, tag="2")]
    pub key: ::prost::alloc::string::String,
}
impl ::prost::Name for File {
const NAME: &'static str = "File";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.File".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.File".into() }}
/// Array type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Array {
    #[prost(message, repeated, tag="1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
}
impl ::prost::Name for Array {
const NAME: &'static str = "Array";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Array".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Array".into() }}
/// Object type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    #[prost(btree_map="string, message", tag="1")]
    #[serde(flatten)]
    pub items: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, Value>,
}
impl ::prost::Name for Object {
const NAME: &'static str = "Object";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Object".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Object".into() }}
/// Value bound type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueBound {
    #[prost(oneof="value_bound::Bound", tags="1, 2, 3")]
    pub bound: ::core::option::Option<value_bound::Bound>,
}
/// Nested message and enum types in `ValueBound`.
pub mod value_bound {
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Bound {
        #[prost(message, tag="1")]
        Inclusive(::prost::alloc::boxed::Box<super::Value>),
        #[prost(message, tag="2")]
        Exclusive(::prost::alloc::boxed::Box<super::Value>),
        #[prost(message, tag="3")]
        Unbounded(super::NullValue),
    }
}
impl ::prost::Name for ValueBound {
const NAME: &'static str = "ValueBound";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.ValueBound".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.ValueBound".into() }}
/// Range type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Range {
    #[prost(message, optional, boxed, tag="1")]
    pub start: ::core::option::Option<::prost::alloc::boxed::Box<ValueBound>>,
    #[prost(message, optional, boxed, tag="2")]
    pub end: ::core::option::Option<::prost::alloc::boxed::Box<ValueBound>>,
}
impl ::prost::Name for Range {
const NAME: &'static str = "Range";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Range".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Range".into() }}
/// Value type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof="value::Value", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17")]
    #[serde(flatten)]
    pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="1")]
        Null(super::NullValue),
        #[prost(bool, tag="2")]
        Bool(bool),
        #[prost(int64, tag="3")]
        Int64(i64),
        #[prost(uint64, tag="4")]
        Uint64(u64),
        #[prost(double, tag="5")]
        Float64(f64),
        #[prost(string, tag="6")]
        String(::prost::alloc::string::String),
        #[prost(bytes, tag="7")]
        Bytes(::prost::bytes::Bytes),
        #[prost(message, tag="8")]
        Decimal(super::Decimal),
        #[prost(message, tag="9")]
        #[serde(with = "crate::serde_duration")]
        Duration(::prost_types::Duration),
        #[prost(message, tag="10")]
        #[serde(with = "crate::serde_timestamp")]
        Datetime(::prost_types::Timestamp),
        #[prost(message, tag="11")]
        Uuid(super::Uuid),
        #[prost(message, tag="12")]
        Array(super::Array),
        #[prost(message, tag="13")]
        Object(super::Object),
        #[prost(message, tag="14")]
        Geometry(super::Geometry),
        #[prost(message, tag="15")]
        RecordId(super::RecordId),
        #[prost(message, tag="16")]
        File(super::File),
        #[prost(message, tag="17")]
        Range(::prost::alloc::boxed::Box<super::Range>),
    }
}
impl ::prost::Name for Value {
const NAME: &'static str = "Value";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Value".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Value".into() }}
/// ID type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Id {
    #[prost(oneof="id::Id", tags="1, 2, 3, 4")]
    pub id: ::core::option::Option<id::Id>,
}
/// Nested message and enum types in `Id`.
pub mod id {
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Id {
        #[prost(int64, tag="1")]
        Int64(i64),
        #[prost(string, tag="2")]
        String(::prost::alloc::string::String),
        #[prost(message, tag="3")]
        Uuid(super::Uuid),
        #[prost(message, tag="4")]
        Array(super::Array),
    }
}
impl ::prost::Name for Id {
const NAME: &'static str = "Id";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Id".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Id".into() }}
/// Variables.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Variables {
    #[prost(btree_map="string, message", tag="1")]
    pub variables: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, Value>,
}
impl ::prost::Name for Variables {
const NAME: &'static str = "Variables";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Variables".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Variables".into() }}
/// Identifier.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ident {
    #[prost(string, tag="1")]
    pub value: ::prost::alloc::string::String,
}
impl ::prost::Name for Ident {
const NAME: &'static str = "Ident";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Ident".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Ident".into() }}
/// Fields selection.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fields {
    /// Whether this is a single VALUE clause.
    #[prost(bool, tag="1")]
    pub single: bool,
    /// Field selection.
    #[prost(message, repeated, tag="2")]
    pub fields: ::prost::alloc::vec::Vec<fields::Field>,
}
/// Nested message and enum types in `Fields`.
pub mod fields {
    /// Single field.
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SingleField {
        /// Expression.
        #[prost(message, optional, tag="1")]
        pub expr: ::core::option::Option<super::Value>,
        /// Alias.
        #[prost(message, optional, tag="2")]
        pub alias: ::core::option::Option<super::Idiom>,
    }
impl ::prost::Name for SingleField {
const NAME: &'static str = "SingleField";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Fields.SingleField".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Fields.SingleField".into() }}
    /// Field selection.
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Field {
        #[prost(oneof="field::Field", tags="1, 2")]
        pub field: ::core::option::Option<field::Field>,
    }
    /// Nested message and enum types in `Field`.
    pub mod field {
        #[derive(serde::Deserialize,serde::Serialize)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Field {
            /// All fields.
            #[prost(message, tag="1")]
            All(super::super::NullValue),
            /// Single field.
            #[prost(message, tag="2")]
            Single(super::SingleField),
        }
    }
impl ::prost::Name for Field {
const NAME: &'static str = "Field";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Fields.Field".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Fields.Field".into() }}
}
impl ::prost::Name for Fields {
const NAME: &'static str = "Fields";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Fields".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Fields".into() }}
/// Idiom which represents a field expression (e.g. `a.b.c` or `a.b\[0\]`).
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Idiom {
    #[prost(string, tag="1")]
    pub value: ::prost::alloc::string::String,
}
impl ::prost::Name for Idiom {
const NAME: &'static str = "Idiom";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Idiom".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Idiom".into() }}
/// Data expression.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Data {
    #[prost(oneof="data::Data", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
    pub data: ::core::option::Option<data::Data>,
}
/// Nested message and enum types in `Data`.
pub mod data {
    /// Set expression (e.g. `a = 1` or `a.b += 1`).
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetExpr {
        /// Idiom.
        #[prost(message, optional, tag="1")]
        pub idiom: ::core::option::Option<super::Idiom>,
        /// Operator.
        #[prost(enumeration="super::Operator", tag="2")]
        pub operator: i32,
        /// Value.
        #[prost(message, optional, tag="3")]
        pub value: ::core::option::Option<super::Value>,
    }
impl ::prost::Name for SetExpr {
const NAME: &'static str = "SetExpr";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Data.SetExpr".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Data.SetExpr".into() }}
    /// Set multiple expressions.
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetMultiExpr {
        #[prost(message, repeated, tag="1")]
        pub items: ::prost::alloc::vec::Vec<SetExpr>,
    }
impl ::prost::Name for SetMultiExpr {
const NAME: &'static str = "SetMultiExpr";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Data.SetMultiExpr".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Data.SetMultiExpr".into() }}
    /// Unset multiple expressions.
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UnsetMultiExpr {
        #[prost(message, repeated, tag="1")]
        pub items: ::prost::alloc::vec::Vec<super::Idiom>,
    }
impl ::prost::Name for UnsetMultiExpr {
const NAME: &'static str = "UnsetMultiExpr";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Data.UnsetMultiExpr".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Data.UnsetMultiExpr".into() }}
    /// Idiom and value pair.
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IdiomValuePair {
        #[prost(message, optional, tag="1")]
        pub idiom: ::core::option::Option<super::Idiom>,
        #[prost(message, optional, tag="2")]
        pub value: ::core::option::Option<super::Value>,
    }
impl ::prost::Name for IdiomValuePair {
const NAME: &'static str = "IdiomValuePair";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Data.IdiomValuePair".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Data.IdiomValuePair".into() }}
    /// Values expression.
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ValuesExpr {
        #[prost(message, repeated, tag="1")]
        pub items: ::prost::alloc::vec::Vec<IdiomValuePair>,
    }
impl ::prost::Name for ValuesExpr {
const NAME: &'static str = "ValuesExpr";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Data.ValuesExpr".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Data.ValuesExpr".into() }}
    /// Values multiple expressions.
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ValuesMultiExpr {
        #[prost(message, repeated, tag="1")]
        pub items: ::prost::alloc::vec::Vec<ValuesExpr>,
    }
impl ::prost::Name for ValuesMultiExpr {
const NAME: &'static str = "ValuesMultiExpr";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Data.ValuesMultiExpr".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Data.ValuesMultiExpr".into() }}
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag="1")]
        Empty(super::NullValue),
        #[prost(message, tag="2")]
        Set(SetMultiExpr),
        #[prost(message, tag="3")]
        Unset(UnsetMultiExpr),
        #[prost(message, tag="4")]
        Patch(super::Value),
        #[prost(message, tag="5")]
        Merge(super::Value),
        #[prost(message, tag="6")]
        Replace(super::Value),
        #[prost(message, tag="7")]
        Content(super::Value),
        #[prost(message, tag="8")]
        Value(super::Value),
        #[prost(message, tag="9")]
        Values(ValuesMultiExpr),
        #[prost(message, tag="10")]
        Update(SetMultiExpr),
    }
}
impl ::prost::Name for Data {
const NAME: &'static str = "Data";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Data".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Data".into() }}
/// Fetchs expression.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fetchs {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<Value>,
}
impl ::prost::Name for Fetchs {
const NAME: &'static str = "Fetchs";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Fetchs".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Fetchs".into() }}
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Output {
    #[prost(oneof="output::Output", tags="1, 2, 3, 4, 5")]
    pub output: ::core::option::Option<output::Output>,
}
/// Nested message and enum types in `Output`.
pub mod output {
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Output {
        #[prost(message, tag="1")]
        Null(super::NullValue),
        #[prost(message, tag="2")]
        Diff(super::NullValue),
        #[prost(message, tag="3")]
        After(super::NullValue),
        #[prost(message, tag="4")]
        Before(super::NullValue),
        #[prost(message, tag="5")]
        Fields(super::Fields),
    }
}
impl ::prost::Name for Output {
const NAME: &'static str = "Output";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Output".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Output".into() }}
/// Wrapper for explain in order to make it optional.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Explain {
    #[prost(bool, tag="1")]
    pub explain: bool,
}
impl ::prost::Name for Explain {
const NAME: &'static str = "Explain";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Explain".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Explain".into() }}
/// Wrapper for start in order to make it optional.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Start {
    #[prost(uint64, tag="1")]
    pub start: u64,
}
impl ::prost::Name for Start {
const NAME: &'static str = "Start";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Start".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Start".into() }}
/// Wrapper for limit in order to make it optional.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Limit {
    #[prost(uint64, tag="1")]
    pub limit: u64,
}
impl ::prost::Name for Limit {
const NAME: &'static str = "Limit";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Limit".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Limit".into() }}
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fetch {
    #[prost(message, optional, tag="1")]
    pub fetch: ::core::option::Option<Fetchs>,
}
impl ::prost::Name for Fetch {
const NAME: &'static str = "Fetch";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.Fetch".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.Fetch".into() }}
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct With {
    /// Indices to use. If not specified, use no indexes
    #[prost(string, repeated, tag="1")]
    pub indexes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for With {
const NAME: &'static str = "With";
const PACKAGE: &'static str = "surrealdb.protocol.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.v1.With".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.v1.With".into() }}
/// Supported operators.
///
/// Note: This is a subset of the operators supported by the SurrealQL parser. This only includes operators that do not take arguments.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Operator {
    Unspecified = 0,
    /// `-`
    Neg = 1,
    /// `!`
    Not = 2,
    /// `||`
    Or = 3,
    /// `&&`
    And = 4,
    /// `?:`
    Tco = 5,
    /// `??`
    Nco = 6,
    /// `+`
    Add = 7,
    /// `-`
    Sub = 8,
    /// `*`
    Mul = 9,
    /// `/`
    Div = 10,
    /// `%`
    Rem = 11,
    /// `**`
    Pow = 12,
    /// `+=`
    Inc = 13,
    /// `-=`
    Dec = 14,
    /// `..`
    Ext = 15,
    /// `=`
    Equal = 16,
    /// `==`
    Exact = 17,
    /// `!=`
    NotEqual = 18,
    /// `*=`
    AllEqual = 19,
    /// `?=`
    AnyEqual = 20,
    /// `<`
    LessThan = 21,
    /// `<=`
    LessThanOrEqual = 22,
    /// `>`
    GreaterThan = 23,
    /// `>=`
    GreaterThanOrEqual = 24,
    /// `∋`
    Contain = 25,
    /// `∌`
    NotContain = 26,
    /// `⊇`
    ContainAll = 27,
    /// `⊃`
    ContainAny = 28,
    /// `⊅`
    ContainNone = 29,
    /// `∈`
    Inside = 30,
    /// `∉`
    NotInside = 31,
    /// `⊆`
    AllInside = 32,
    /// `⊂`
    AnyInside = 33,
    /// `⊄`
    NoneInside = 34,
    /// `OUTSIDE`
    Outside = 35,
    /// `INTERSECTS`
    Intersects = 36,
}
impl Operator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPERATOR_UNSPECIFIED",
            Self::Neg => "OPERATOR_NEG",
            Self::Not => "OPERATOR_NOT",
            Self::Or => "OPERATOR_OR",
            Self::And => "OPERATOR_AND",
            Self::Tco => "OPERATOR_TCO",
            Self::Nco => "OPERATOR_NCO",
            Self::Add => "OPERATOR_ADD",
            Self::Sub => "OPERATOR_SUB",
            Self::Mul => "OPERATOR_MUL",
            Self::Div => "OPERATOR_DIV",
            Self::Rem => "OPERATOR_REM",
            Self::Pow => "OPERATOR_POW",
            Self::Inc => "OPERATOR_INC",
            Self::Dec => "OPERATOR_DEC",
            Self::Ext => "OPERATOR_EXT",
            Self::Equal => "OPERATOR_EQUAL",
            Self::Exact => "OPERATOR_EXACT",
            Self::NotEqual => "OPERATOR_NOT_EQUAL",
            Self::AllEqual => "OPERATOR_ALL_EQUAL",
            Self::AnyEqual => "OPERATOR_ANY_EQUAL",
            Self::LessThan => "OPERATOR_LESS_THAN",
            Self::LessThanOrEqual => "OPERATOR_LESS_THAN_OR_EQUAL",
            Self::GreaterThan => "OPERATOR_GREATER_THAN",
            Self::GreaterThanOrEqual => "OPERATOR_GREATER_THAN_OR_EQUAL",
            Self::Contain => "OPERATOR_CONTAIN",
            Self::NotContain => "OPERATOR_NOT_CONTAIN",
            Self::ContainAll => "OPERATOR_CONTAIN_ALL",
            Self::ContainAny => "OPERATOR_CONTAIN_ANY",
            Self::ContainNone => "OPERATOR_CONTAIN_NONE",
            Self::Inside => "OPERATOR_INSIDE",
            Self::NotInside => "OPERATOR_NOT_INSIDE",
            Self::AllInside => "OPERATOR_ALL_INSIDE",
            Self::AnyInside => "OPERATOR_ANY_INSIDE",
            Self::NoneInside => "OPERATOR_NONE_INSIDE",
            Self::Outside => "OPERATOR_OUTSIDE",
            Self::Intersects => "OPERATOR_INTERSECTS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
            "OPERATOR_NEG" => Some(Self::Neg),
            "OPERATOR_NOT" => Some(Self::Not),
            "OPERATOR_OR" => Some(Self::Or),
            "OPERATOR_AND" => Some(Self::And),
            "OPERATOR_TCO" => Some(Self::Tco),
            "OPERATOR_NCO" => Some(Self::Nco),
            "OPERATOR_ADD" => Some(Self::Add),
            "OPERATOR_SUB" => Some(Self::Sub),
            "OPERATOR_MUL" => Some(Self::Mul),
            "OPERATOR_DIV" => Some(Self::Div),
            "OPERATOR_REM" => Some(Self::Rem),
            "OPERATOR_POW" => Some(Self::Pow),
            "OPERATOR_INC" => Some(Self::Inc),
            "OPERATOR_DEC" => Some(Self::Dec),
            "OPERATOR_EXT" => Some(Self::Ext),
            "OPERATOR_EQUAL" => Some(Self::Equal),
            "OPERATOR_EXACT" => Some(Self::Exact),
            "OPERATOR_NOT_EQUAL" => Some(Self::NotEqual),
            "OPERATOR_ALL_EQUAL" => Some(Self::AllEqual),
            "OPERATOR_ANY_EQUAL" => Some(Self::AnyEqual),
            "OPERATOR_LESS_THAN" => Some(Self::LessThan),
            "OPERATOR_LESS_THAN_OR_EQUAL" => Some(Self::LessThanOrEqual),
            "OPERATOR_GREATER_THAN" => Some(Self::GreaterThan),
            "OPERATOR_GREATER_THAN_OR_EQUAL" => Some(Self::GreaterThanOrEqual),
            "OPERATOR_CONTAIN" => Some(Self::Contain),
            "OPERATOR_NOT_CONTAIN" => Some(Self::NotContain),
            "OPERATOR_CONTAIN_ALL" => Some(Self::ContainAll),
            "OPERATOR_CONTAIN_ANY" => Some(Self::ContainAny),
            "OPERATOR_CONTAIN_NONE" => Some(Self::ContainNone),
            "OPERATOR_INSIDE" => Some(Self::Inside),
            "OPERATOR_NOT_INSIDE" => Some(Self::NotInside),
            "OPERATOR_ALL_INSIDE" => Some(Self::AllInside),
            "OPERATOR_ANY_INSIDE" => Some(Self::AnyInside),
            "OPERATOR_NONE_INSIDE" => Some(Self::NoneInside),
            "OPERATOR_OUTSIDE" => Some(Self::Outside),
            "OPERATOR_INTERSECTS" => Some(Self::Intersects),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
