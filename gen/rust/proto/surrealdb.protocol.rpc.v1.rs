// @generated
// This file is @generated by prost-build.
/// Request to check the health of the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HealthRequest {
}
impl ::prost::Name for HealthRequest {
const NAME: &'static str = "HealthRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.HealthRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.HealthRequest".into() }}
/// Response to a health check request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HealthResponse {
}
impl ::prost::Name for HealthResponse {
const NAME: &'static str = "HealthResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.HealthResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.HealthResponse".into() }}
/// Request to get the version of the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VersionRequest {
}
impl ::prost::Name for VersionRequest {
const NAME: &'static str = "VersionRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.VersionRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.VersionRequest".into() }}
/// Response to a version request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionResponse {
    #[prost(string, tag="1")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for VersionResponse {
const NAME: &'static str = "VersionResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.VersionResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.VersionResponse".into() }}
/// Request to sign up a new user.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignupRequest {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub database: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub access_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub variables: ::core::option::Option<super::super::v1::Variables>,
}
impl ::prost::Name for SignupRequest {
const NAME: &'static str = "SignupRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SignupRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SignupRequest".into() }}
/// Response to a signup request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignupResponse {
    #[prost(message, optional, tag="1")]
    pub value: ::core::option::Option<super::super::v1::Value>,
}
impl ::prost::Name for SignupResponse {
const NAME: &'static str = "SignupResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SignupResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SignupResponse".into() }}
/// Request to sign in a user.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigninRequest {
    #[prost(message, optional, tag="1")]
    pub access_method: ::core::option::Option<AccessMethod>,
}
impl ::prost::Name for SigninRequest {
const NAME: &'static str = "SigninRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SigninRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SigninRequest".into() }}
/// Response to a signin request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigninResponse {
    #[prost(message, optional, tag="1")]
    pub value: ::core::option::Option<super::super::v1::Value>,
}
impl ::prost::Name for SigninResponse {
const NAME: &'static str = "SigninResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SigninResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SigninResponse".into() }}
/// Request to authenticate a user.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateRequest {
    #[prost(string, tag="1")]
    pub token: ::prost::alloc::string::String,
}
impl ::prost::Name for AuthenticateRequest {
const NAME: &'static str = "AuthenticateRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.AuthenticateRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.AuthenticateRequest".into() }}
/// Response to an authenticate request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateResponse {
    #[prost(message, optional, tag="1")]
    pub value: ::core::option::Option<super::super::v1::Value>,
}
impl ::prost::Name for AuthenticateResponse {
const NAME: &'static str = "AuthenticateResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.AuthenticateResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.AuthenticateResponse".into() }}
/// Request to use a namespace and database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UseRequest {
    /// The namespace to use.
    /// An empty namespace will unset the current namespace.
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    /// The database to use.
    /// An empty database will unset the current database.
    #[prost(string, tag="2")]
    pub database: ::prost::alloc::string::String,
}
impl ::prost::Name for UseRequest {
const NAME: &'static str = "UseRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UseRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UseRequest".into() }}
/// Response to a use request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UseResponse {
    /// The namespace that is now in use.
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    /// The database that is now in use.
    #[prost(string, tag="2")]
    pub database: ::prost::alloc::string::String,
}
impl ::prost::Name for UseResponse {
const NAME: &'static str = "UseResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UseResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UseResponse".into() }}
/// Request to set a global variable for the current session.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRequest {
    /// The name of the variable to set.
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// The value to set the variable to.
    #[prost(message, optional, tag="2")]
    pub value: ::core::option::Option<super::super::v1::Value>,
}
impl ::prost::Name for SetRequest {
const NAME: &'static str = "SetRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SetRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SetRequest".into() }}
/// Response to a set request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetResponse {
}
impl ::prost::Name for SetResponse {
const NAME: &'static str = "SetResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SetResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SetResponse".into() }}
/// Request to unset a global variable for the current session.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsetRequest {
    /// The name of the variable to unset.
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for UnsetRequest {
const NAME: &'static str = "UnsetRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UnsetRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UnsetRequest".into() }}
/// Response to an unset request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnsetResponse {
}
impl ::prost::Name for UnsetResponse {
const NAME: &'static str = "UnsetResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UnsetResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UnsetResponse".into() }}
/// Request to invalidate the current session.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvalidateRequest {
}
impl ::prost::Name for InvalidateRequest {
const NAME: &'static str = "InvalidateRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.InvalidateRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.InvalidateRequest".into() }}
/// Response to an invalidate request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvalidateResponse {
}
impl ::prost::Name for InvalidateResponse {
const NAME: &'static str = "InvalidateResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.InvalidateResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.InvalidateResponse".into() }}
/// Request to reset all global variables for the current session.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResetRequest {
}
impl ::prost::Name for ResetRequest {
const NAME: &'static str = "ResetRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ResetRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ResetRequest".into() }}
/// Response to a reset request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResetResponse {
}
impl ::prost::Name for ResetResponse {
const NAME: &'static str = "ResetResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ResetResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ResetResponse".into() }}
/// Request to import data into the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportSqlRequest {
    #[prost(string, tag="1")]
    pub statement: ::prost::alloc::string::String,
}
impl ::prost::Name for ImportSqlRequest {
const NAME: &'static str = "ImportSqlRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ImportSqlRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ImportSqlRequest".into() }}
/// Response to an import request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportSqlResponse {
}
impl ::prost::Name for ImportSqlResponse {
const NAME: &'static str = "ImportSqlResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ImportSqlResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ImportSqlResponse".into() }}
/// Request to export data from the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportSqlRequest {
    #[prost(bool, tag="1")]
    pub users: bool,
    #[prost(bool, tag="2")]
    pub accesses: bool,
    #[prost(bool, tag="3")]
    pub params: bool,
    #[prost(bool, tag="4")]
    pub functions: bool,
    #[prost(bool, tag="5")]
    pub analyzers: bool,
    #[prost(message, optional, tag="6")]
    pub tables: ::core::option::Option<export_sql_request::Tables>,
    #[prost(bool, tag="7")]
    pub versions: bool,
    #[prost(bool, tag="8")]
    pub records: bool,
    #[prost(bool, tag="9")]
    pub sequences: bool,
}
/// Nested message and enum types in `ExportSqlRequest`.
pub mod export_sql_request {
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SelectedTables {
        #[prost(string, repeated, tag="1")]
        pub tables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
impl ::prost::Name for SelectedTables {
const NAME: &'static str = "SelectedTables";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ExportSqlRequest.SelectedTables".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ExportSqlRequest.SelectedTables".into() }}
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tables {
        #[prost(oneof="tables::Selection", tags="1, 2, 3")]
        pub selection: ::core::option::Option<tables::Selection>,
    }
    /// Nested message and enum types in `Tables`.
    pub mod tables {
        #[derive(serde::Deserialize,serde::Serialize)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Selection {
            #[prost(message, tag="1")]
            All(super::super::super::super::v1::NullValue),
            #[prost(message, tag="2")]
            None(super::super::super::super::v1::NullValue),
            #[prost(message, tag="3")]
            Selected(super::SelectedTables),
        }
    }
impl ::prost::Name for Tables {
const NAME: &'static str = "Tables";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ExportSqlRequest.Tables".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ExportSqlRequest.Tables".into() }}
}
impl ::prost::Name for ExportSqlRequest {
const NAME: &'static str = "ExportSqlRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ExportSqlRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ExportSqlRequest".into() }}
/// Response to an export request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportSqlResponse {
    #[prost(string, tag="1")]
    pub statement: ::prost::alloc::string::String,
}
impl ::prost::Name for ExportSqlResponse {
const NAME: &'static str = "ExportSqlResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ExportSqlResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ExportSqlResponse".into() }}
/// Request to export the ML model.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportMlModelRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for ExportMlModelRequest {
const NAME: &'static str = "ExportMlModelRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ExportMlModelRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ExportMlModelRequest".into() }}
/// Response to an export request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportMlModelResponse {
    #[prost(bytes="bytes", tag="1")]
    pub model: ::prost::bytes::Bytes,
}
impl ::prost::Name for ExportMlModelResponse {
const NAME: &'static str = "ExportMlModelResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ExportMlModelResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ExportMlModelResponse".into() }}
/// Request to issue a live query.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeRequest {
    #[prost(oneof="subscribe_request::SubscribeTo", tags="1, 2")]
    pub subscribe_to: ::core::option::Option<subscribe_request::SubscribeTo>,
}
/// Nested message and enum types in `SubscribeRequest`.
pub mod subscribe_request {
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubscribeTo {
        #[prost(message, tag="1")]
        LiveQueryId(super::super::super::v1::Uuid),
        #[prost(message, tag="2")]
        Query(super::QueryRequest),
    }
}
impl ::prost::Name for SubscribeRequest {
const NAME: &'static str = "SubscribeRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SubscribeRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SubscribeRequest".into() }}
/// Response to a live query.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeResponse {
    #[prost(message, optional, tag="1")]
    pub notification: ::core::option::Option<Notification>,
}
impl ::prost::Name for SubscribeResponse {
const NAME: &'static str = "SubscribeResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SubscribeResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SubscribeResponse".into() }}
/// A notification from a live query.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notification {
    #[prost(message, optional, tag="1")]
    pub live_query_id: ::core::option::Option<super::super::v1::Uuid>,
    #[prost(enumeration="Action", tag="2")]
    pub action: i32,
    #[prost(message, optional, tag="3")]
    pub record_id: ::core::option::Option<super::super::v1::RecordId>,
    #[prost(message, optional, tag="4")]
    pub value: ::core::option::Option<super::super::v1::Value>,
}
impl ::prost::Name for Notification {
const NAME: &'static str = "Notification";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.Notification".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.Notification".into() }}
/// Request to query the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRequest {
    #[prost(string, tag="1")]
    pub query: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub variables: ::core::option::Option<super::super::v1::Variables>,
    #[prost(message, optional, tag="3")]
    pub txn_id: ::core::option::Option<super::super::v1::Uuid>,
}
impl ::prost::Name for QueryRequest {
const NAME: &'static str = "QueryRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.QueryRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.QueryRequest".into() }}
/// Streaming response to a query request.
///
/// When a query has 5 statements, there will be 5 unique query IDs (0..4). Each query
/// ID's response can be assumed to be sent in order, but may be interleaved in the future.
///
/// Expect only the last response for each query ID to contain the query stats.
/// 
/// Responses are ordered by query index, then batch index. For example:
///   QueryResponse(query_index=0, batch_index=0, stats=None)
///   QueryResponse(query_index=0, batch_index=1, stats=Some(..))
///   QueryResponse(query_index=1, batch_index=0, stats=Some(..))
///   QueryResponse(query_index=2, batch_index=0, stats=None)
///   QueryResponse(query_index=2, batch_index=1, stats=None)
///   QueryResponse(query_index=2, batch_index=2, stats=Some(..))
///   QueryResponse(query_index=3, batch_index=0, stats=Some(..))
///   QueryResponse(query_index=4, batch_index=0, stats=Some(..))
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResponse {
    /// The index of the query result.
    #[prost(uint32, tag="1")]
    pub query_index: u32,
    /// The index of the batch within the given query.
    #[prost(uint64, tag="2")]
    pub batch_index: u64,
    /// The total number of query results.
    ///
    /// Every response will contain the same value for this field so you can
    /// use the value from the first response to determine how many query results
    /// to expect.
    ///
    /// Note: This is NOT the number of records returned.
    ///
    /// Examples:
    ///    query = "SELECT * FROM users;"
    ///    result_count = 1
    ///
    ///    query = """
    ///    SELECT * FROM users;
    ///    SELECT * FROM posts;
    ///    """
    ///    result_count = 2
    ///
    ///    query = """
    ///    SELECT * FROM users;
    ///    SELECT * FROM posts;
    ///    SELECT * FROM comments;
    ///    """
    ///    result_count = 3
    #[prost(uint32, tag="3")]
    pub result_count: u32,
    /// The kind of query response.
    #[prost(enumeration="QueryResponseKind", tag="4")]
    pub kind: i32,
    /// The query stats.
    /// This is only expected to be present in the last batch of each query.
    #[prost(message, optional, tag="5")]
    pub stats: ::core::option::Option<QueryStats>,
    /// The error, if any.
    #[prost(message, optional, tag="6")]
    pub error: ::core::option::Option<QueryError>,
    /// A batch of values.
    #[prost(message, repeated, tag="7")]
    pub values: ::prost::alloc::vec::Vec<super::super::v1::Value>,
}
impl ::prost::Name for QueryResponse {
const NAME: &'static str = "QueryResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.QueryResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.QueryResponse".into() }}
/// Query statistics.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryStats {
    /// The number of records returned. -1 if unknown.
    #[prost(int64, tag="1")]
    pub records_returned: i64,
    /// The number of bytes returned. -1 if unknown.
    #[prost(int64, tag="2")]
    pub bytes_returned: i64,
    /// The number of records scanned. -1 if unknown.
    #[prost(int64, tag="3")]
    pub records_scanned: i64,
    /// The number of bytes scanned. -1 if unknown.
    #[prost(int64, tag="4")]
    pub bytes_scanned: i64,
    /// The duration of the query.
    #[prost(message, optional, tag="5")]
    #[serde(with = "crate::serde_duration_optional")]
    pub execution_duration: ::core::option::Option<::prost_types::Duration>,
}
impl ::prost::Name for QueryStats {
const NAME: &'static str = "QueryStats";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.QueryStats".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.QueryStats".into() }}
/// Query error.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryError {
    /// The error code.
    #[prost(int64, tag="1")]
    pub code: i64,
    /// The error message.
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryError {
const NAME: &'static str = "QueryError";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.QueryError".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.QueryError".into() }}
/// Root user credentials.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RootUserCredentials {
    #[prost(string, tag="1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub password: ::prost::alloc::string::String,
}
impl ::prost::Name for RootUserCredentials {
const NAME: &'static str = "RootUserCredentials";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.RootUserCredentials".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.RootUserCredentials".into() }}
/// Namespace access credentials.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespaceAccessCredentials {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub access: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub key: ::prost::alloc::string::String,
}
impl ::prost::Name for NamespaceAccessCredentials {
const NAME: &'static str = "NamespaceAccessCredentials";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.NamespaceAccessCredentials".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.NamespaceAccessCredentials".into() }}
/// Database access credentials.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseAccessCredentials {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub database: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub access: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub refresh: ::prost::alloc::string::String,
}
impl ::prost::Name for DatabaseAccessCredentials {
const NAME: &'static str = "DatabaseAccessCredentials";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.DatabaseAccessCredentials".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.DatabaseAccessCredentials".into() }}
/// Namespace user credentials.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespaceUserCredentials {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub password: ::prost::alloc::string::String,
}
impl ::prost::Name for NamespaceUserCredentials {
const NAME: &'static str = "NamespaceUserCredentials";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.NamespaceUserCredentials".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.NamespaceUserCredentials".into() }}
/// Database user credentials.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseUserCredentials {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub database: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub password: ::prost::alloc::string::String,
}
impl ::prost::Name for DatabaseUserCredentials {
const NAME: &'static str = "DatabaseUserCredentials";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.DatabaseUserCredentials".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.DatabaseUserCredentials".into() }}
/// Access token.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessToken {
    #[prost(string, tag="1")]
    pub token: ::prost::alloc::string::String,
}
impl ::prost::Name for AccessToken {
const NAME: &'static str = "AccessToken";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.AccessToken".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.AccessToken".into() }}
/// Method of authenticating with the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessMethod {
    #[prost(oneof="access_method::Method", tags="1, 2, 3, 4, 5, 6")]
    pub method: ::core::option::Option<access_method::Method>,
}
/// Nested message and enum types in `AccessMethod`.
pub mod access_method {
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Method {
        #[prost(message, tag="1")]
        Root(super::RootUserCredentials),
        #[prost(message, tag="2")]
        Namespace(super::NamespaceAccessCredentials),
        #[prost(message, tag="3")]
        Database(super::DatabaseAccessCredentials),
        #[prost(message, tag="4")]
        NamespaceUser(super::NamespaceUserCredentials),
        #[prost(message, tag="5")]
        DatabaseUser(super::DatabaseUserCredentials),
        #[prost(message, tag="6")]
        AccessToken(super::AccessToken),
    }
}
impl ::prost::Name for AccessMethod {
const NAME: &'static str = "AccessMethod";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.AccessMethod".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.AccessMethod".into() }}
/// Action type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Action {
    Unspecified = 0,
    Created = 1,
    Updated = 2,
    Deleted = 3,
    Killed = 4,
}
impl Action {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACTION_UNSPECIFIED",
            Self::Created => "ACTION_CREATED",
            Self::Updated => "ACTION_UPDATED",
            Self::Deleted => "ACTION_DELETED",
            Self::Killed => "ACTION_KILLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTION_CREATED" => Some(Self::Created),
            "ACTION_UPDATED" => Some(Self::Updated),
            "ACTION_DELETED" => Some(Self::Deleted),
            "ACTION_KILLED" => Some(Self::Killed),
            _ => None,
        }
    }
}
/// The kind of query response.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryResponseKind {
    Unspecified = 0,
    /// A single value is contained in the response and no further responses are expected.
    ///
    /// This is used in the context of `SELECT ONLY ...` or other queries that should only ever return a single value.
    Single = 1,
    /// A batch of values is contained in the response and further responses may be expected.
    Batched = 2,
    /// The final response from a batched query. No further responses for this query ID are expected.
    ///
    /// This response should always contain the query stats.
    ///
    /// Note: If all response values can fit in a single batch, this will be the first and only response.
    BatchedFinal = 3,
}
impl QueryResponseKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "QUERY_RESPONSE_KIND_UNSPECIFIED",
            Self::Single => "QUERY_RESPONSE_KIND_SINGLE",
            Self::Batched => "QUERY_RESPONSE_KIND_BATCHED",
            Self::BatchedFinal => "QUERY_RESPONSE_KIND_BATCHED_FINAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUERY_RESPONSE_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "QUERY_RESPONSE_KIND_SINGLE" => Some(Self::Single),
            "QUERY_RESPONSE_KIND_BATCHED" => Some(Self::Batched),
            "QUERY_RESPONSE_KIND_BATCHED_FINAL" => Some(Self::BatchedFinal),
            _ => None,
        }
    }
}
include!("surrealdb.protocol.rpc.v1.tonic.rs");
// @@protoc_insertion_point(module)