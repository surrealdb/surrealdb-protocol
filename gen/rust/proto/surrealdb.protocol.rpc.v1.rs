// @generated
// This file is @generated by prost-build.
/// Request to check the health of the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HealthRequest {
}
impl ::prost::Name for HealthRequest {
const NAME: &'static str = "HealthRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.HealthRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.HealthRequest".into() }}
/// Response to a health check request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HealthResponse {
}
impl ::prost::Name for HealthResponse {
const NAME: &'static str = "HealthResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.HealthResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.HealthResponse".into() }}
/// Request to get the version of the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VersionRequest {
}
impl ::prost::Name for VersionRequest {
const NAME: &'static str = "VersionRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.VersionRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.VersionRequest".into() }}
/// Response to a version request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionResponse {
    #[prost(string, tag="1")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for VersionResponse {
const NAME: &'static str = "VersionResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.VersionResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.VersionResponse".into() }}
/// Request to get information about the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InfoRequest {
}
impl ::prost::Name for InfoRequest {
const NAME: &'static str = "InfoRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.InfoRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.InfoRequest".into() }}
/// Response to an info request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InfoResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for InfoResponse {
const NAME: &'static str = "InfoResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.InfoResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.InfoResponse".into() }}
/// Request to change the current namespace and database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UseRequest {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub database: ::prost::alloc::string::String,
}
impl ::prost::Name for UseRequest {
const NAME: &'static str = "UseRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UseRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UseRequest".into() }}
/// Response to a use request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UseResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for UseResponse {
const NAME: &'static str = "UseResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UseResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UseResponse".into() }}
/// Request to sign up a new user.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignupRequest {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub database: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub access_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub variables: ::core::option::Option<Variables>,
}
impl ::prost::Name for SignupRequest {
const NAME: &'static str = "SignupRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SignupRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SignupRequest".into() }}
/// Response to a signup request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignupResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for SignupResponse {
const NAME: &'static str = "SignupResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SignupResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SignupResponse".into() }}
/// Request to sign in a user.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigninRequest {
    #[prost(message, optional, tag="1")]
    pub access_method: ::core::option::Option<AccessMethod>,
}
impl ::prost::Name for SigninRequest {
const NAME: &'static str = "SigninRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SigninRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SigninRequest".into() }}
/// Response to a signin request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigninResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for SigninResponse {
const NAME: &'static str = "SigninResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SigninResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SigninResponse".into() }}
/// Request to authenticate a user.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateRequest {
    #[prost(string, tag="1")]
    pub token: ::prost::alloc::string::String,
}
impl ::prost::Name for AuthenticateRequest {
const NAME: &'static str = "AuthenticateRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.AuthenticateRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.AuthenticateRequest".into() }}
/// Response to an authenticate request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for AuthenticateResponse {
const NAME: &'static str = "AuthenticateResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.AuthenticateResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.AuthenticateResponse".into() }}
/// Request to invalidate a user.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvalidateRequest {
}
impl ::prost::Name for InvalidateRequest {
const NAME: &'static str = "InvalidateRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.InvalidateRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.InvalidateRequest".into() }}
/// Response to an invalidate request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvalidateResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for InvalidateResponse {
const NAME: &'static str = "InvalidateResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.InvalidateResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.InvalidateResponse".into() }}
/// Request to reset the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResetRequest {
}
impl ::prost::Name for ResetRequest {
const NAME: &'static str = "ResetRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ResetRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ResetRequest".into() }}
/// Response to a reset request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for ResetResponse {
const NAME: &'static str = "ResetResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ResetResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ResetResponse".into() }}
/// Request to kill a live query.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KillRequest {
    #[prost(string, tag="1")]
    pub live_id: ::prost::alloc::string::String,
}
impl ::prost::Name for KillRequest {
const NAME: &'static str = "KillRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.KillRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.KillRequest".into() }}
/// Response to a kill request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KillResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for KillResponse {
const NAME: &'static str = "KillResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.KillResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.KillResponse".into() }}
/// Request to issue a live query.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveRequest {
    #[prost(message, optional, tag="1")]
    pub what: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="2")]
    pub expr: ::core::option::Option<super::super::v1::Fields>,
    #[prost(message, optional, tag="3")]
    pub cond: ::core::option::Option<super::super::v1::Value>,
}
impl ::prost::Name for LiveRequest {
const NAME: &'static str = "LiveRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.LiveRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.LiveRequest".into() }}
/// Request to set a value.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRequest {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub value: ::core::option::Option<super::super::v1::Value>,
}
impl ::prost::Name for SetRequest {
const NAME: &'static str = "SetRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SetRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SetRequest".into() }}
/// Response to a set request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for SetResponse {
const NAME: &'static str = "SetResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SetResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SetResponse".into() }}
/// Request to unset a value.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsetRequest {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
}
impl ::prost::Name for UnsetRequest {
const NAME: &'static str = "UnsetRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UnsetRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UnsetRequest".into() }}
/// Response to an unset request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsetResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for UnsetResponse {
const NAME: &'static str = "UnsetResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UnsetResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UnsetResponse".into() }}
/// Request to create a new record.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRequest {
    #[prost(message, optional, tag="1")]
    pub txn: ::core::option::Option<super::super::v1::Uuid>,
    #[prost(bool, tag="2")]
    pub only: bool,
    #[prost(message, repeated, tag="3")]
    pub what: ::prost::alloc::vec::Vec<super::super::v1::Value>,
    #[prost(message, optional, tag="4")]
    pub data: ::core::option::Option<super::super::v1::Data>,
    #[prost(message, optional, tag="5")]
    pub output: ::core::option::Option<super::super::v1::Output>,
    #[prost(message, optional, tag="6")]
    #[serde(with = "crate::serde_duration_optional")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag="7")]
    pub parallel: bool,
    #[prost(message, optional, tag="8")]
    pub version: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="9")]
    pub variables: ::core::option::Option<Variables>,
}
impl ::prost::Name for CreateRequest {
const NAME: &'static str = "CreateRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.CreateRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.CreateRequest".into() }}
/// Response to a create request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for CreateResponse {
const NAME: &'static str = "CreateResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.CreateResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.CreateResponse".into() }}
/// Request to select values from the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectRequest {
    #[prost(message, optional, tag="1")]
    pub txn: ::core::option::Option<super::super::v1::Uuid>,
    #[prost(message, optional, tag="2")]
    pub expr: ::core::option::Option<super::super::v1::Fields>,
    #[prost(message, optional, tag="3")]
    pub omit: ::core::option::Option<super::super::v1::Value>,
    #[prost(bool, tag="4")]
    pub only: bool,
    #[prost(message, repeated, tag="5")]
    pub what: ::prost::alloc::vec::Vec<super::super::v1::Value>,
    #[prost(message, optional, tag="6")]
    pub with: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="7")]
    pub cond: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="8")]
    pub split: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="9")]
    pub group: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="10")]
    pub order: ::core::option::Option<super::super::v1::Value>,
    #[prost(int64, tag="11")]
    pub start: i64,
    #[prost(int64, tag="12")]
    pub limit: i64,
    #[prost(message, optional, tag="13")]
    pub fetch: ::core::option::Option<super::super::v1::Fetchs>,
    #[prost(message, optional, tag="14")]
    pub version: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="15")]
    #[serde(with = "crate::serde_duration_optional")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag="16")]
    pub parallel: bool,
    #[prost(message, optional, tag="17")]
    pub explain: ::core::option::Option<super::super::v1::Explain>,
    #[prost(bool, tag="18")]
    pub tempfiles: bool,
    #[prost(message, optional, tag="19")]
    pub variables: ::core::option::Option<Variables>,
}
impl ::prost::Name for SelectRequest {
const NAME: &'static str = "SelectRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SelectRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SelectRequest".into() }}
/// Response to a select request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for SelectResponse {
const NAME: &'static str = "SelectResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.SelectResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.SelectResponse".into() }}
/// Request to insert a new record.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRequest {
    #[prost(message, optional, tag="1")]
    pub txn: ::core::option::Option<super::super::v1::Uuid>,
    #[prost(message, optional, tag="2")]
    pub into: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="3")]
    pub data: ::core::option::Option<super::super::v1::Data>,
    #[prost(bool, tag="4")]
    pub ignore: bool,
    #[prost(message, optional, tag="5")]
    pub update: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="6")]
    pub output: ::core::option::Option<super::super::v1::Output>,
    #[prost(message, optional, tag="7")]
    #[serde(with = "crate::serde_duration_optional")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag="8")]
    pub parallel: bool,
    #[prost(bool, tag="9")]
    pub relation: bool,
    #[prost(message, optional, tag="10")]
    pub version: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="11")]
    pub variables: ::core::option::Option<Variables>,
}
impl ::prost::Name for InsertRequest {
const NAME: &'static str = "InsertRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.InsertRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.InsertRequest".into() }}
/// Response to an insert request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for InsertResponse {
const NAME: &'static str = "InsertResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.InsertResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.InsertResponse".into() }}
/// Request to upsert a record.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertRequest {
    #[prost(message, optional, tag="1")]
    pub txn: ::core::option::Option<super::super::v1::Uuid>,
    #[prost(bool, tag="2")]
    pub only: bool,
    #[prost(message, repeated, tag="3")]
    pub what: ::prost::alloc::vec::Vec<super::super::v1::Value>,
    #[prost(message, optional, tag="4")]
    pub with: ::core::option::Option<super::super::v1::With>,
    #[prost(message, optional, tag="5")]
    pub data: ::core::option::Option<super::super::v1::Data>,
    #[prost(message, optional, tag="6")]
    pub cond: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="7")]
    pub output: ::core::option::Option<super::super::v1::Output>,
    #[prost(message, optional, tag="8")]
    #[serde(with = "crate::serde_duration_optional")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag="9")]
    pub parallel: bool,
    #[prost(message, optional, tag="10")]
    pub explain: ::core::option::Option<super::super::v1::Explain>,
    #[prost(message, optional, tag="11")]
    pub variables: ::core::option::Option<Variables>,
}
impl ::prost::Name for UpsertRequest {
const NAME: &'static str = "UpsertRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UpsertRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UpsertRequest".into() }}
/// Response to an upsert request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for UpsertResponse {
const NAME: &'static str = "UpsertResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UpsertResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UpsertResponse".into() }}
/// Request to update a record.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRequest {
    #[prost(message, optional, tag="1")]
    pub txn: ::core::option::Option<super::super::v1::Uuid>,
    #[prost(bool, tag="2")]
    pub only: bool,
    #[prost(message, repeated, tag="3")]
    pub what: ::prost::alloc::vec::Vec<super::super::v1::Value>,
    #[prost(message, optional, tag="4")]
    pub with: ::core::option::Option<super::super::v1::With>,
    #[prost(message, optional, tag="5")]
    pub data: ::core::option::Option<super::super::v1::Data>,
    #[prost(message, optional, tag="6")]
    pub cond: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="7")]
    pub output: ::core::option::Option<super::super::v1::Output>,
    #[prost(message, optional, tag="9")]
    #[serde(with = "crate::serde_duration_optional")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag="10")]
    pub parallel: bool,
    #[prost(message, optional, tag="11")]
    pub explain: ::core::option::Option<super::super::v1::Explain>,
    #[prost(message, optional, tag="12")]
    pub variables: ::core::option::Option<Variables>,
}
impl ::prost::Name for UpdateRequest {
const NAME: &'static str = "UpdateRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UpdateRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UpdateRequest".into() }}
/// Response to an update request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for UpdateResponse {
const NAME: &'static str = "UpdateResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.UpdateResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.UpdateResponse".into() }}
/// Request to delete a record.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRequest {
    #[prost(message, optional, tag="1")]
    pub txn: ::core::option::Option<super::super::v1::Uuid>,
    #[prost(bool, tag="2")]
    pub only: bool,
    #[prost(message, repeated, tag="3")]
    pub what: ::prost::alloc::vec::Vec<super::super::v1::Value>,
    #[prost(message, optional, tag="4")]
    pub with: ::core::option::Option<super::super::v1::With>,
    #[prost(message, optional, tag="5")]
    pub cond: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="6")]
    pub output: ::core::option::Option<super::super::v1::Output>,
    #[prost(message, optional, tag="7")]
    #[serde(with = "crate::serde_duration_optional")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag="8")]
    pub parallel: bool,
    #[prost(message, optional, tag="9")]
    pub explain: ::core::option::Option<super::super::v1::Explain>,
    #[prost(message, optional, tag="10")]
    pub variables: ::core::option::Option<Variables>,
}
impl ::prost::Name for DeleteRequest {
const NAME: &'static str = "DeleteRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.DeleteRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.DeleteRequest".into() }}
/// Response to a delete request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for DeleteResponse {
const NAME: &'static str = "DeleteResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.DeleteResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.DeleteResponse".into() }}
/// Request to query the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRequest {
    #[prost(string, tag="1")]
    pub query: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub variables: ::core::option::Option<Variables>,
}
impl ::prost::Name for QueryRequest {
const NAME: &'static str = "QueryRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.QueryRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.QueryRequest".into() }}
/// Streaming response to a query request.
///
/// When a query has 5 statements, there will be 5 unique query IDs (0..4). Each query
/// ID's response can be assumed to be sent in order, but may be interleaved in the future.
///
/// Expect the first response for each query ID to contain the query stats, subsequent
/// value batches may elide the stats.
/// 
/// Responses are ordered by query index, then batch index. For example:
///   QueryResponse(query_index=0, batch_index=0)
///   QueryResponse(query_index=0, batch_index=1)
///   QueryResponse(query_index=1, batch_index=0)
///   QueryResponse(query_index=2, batch_index=0)
///   QueryResponse(query_index=2, batch_index=1)
///   QueryResponse(query_index=2, batch_index=2)
///   QueryResponse(query_index=3, batch_index=0)
///   QueryResponse(query_index=4, batch_index=0)
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResponse {
    /// The index of the query.
    #[prost(uint32, tag="1")]
    pub query_index: u32,
    /// The index of the batch within the given query.
    #[prost(uint64, tag="2")]
    pub batch_index: u64,
    /// The query stats.
    #[prost(message, optional, tag="3")]
    pub stats: ::core::option::Option<QueryStats>,
    /// The value batch.
    #[prost(message, optional, tag="4")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for QueryResponse {
const NAME: &'static str = "QueryResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.QueryResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.QueryResponse".into() }}
/// Query statistics.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryStats {
    /// The number of records returned. -1 if unknown.
    #[prost(int64, tag="1")]
    pub num_records: i64,
    /// The start time of the query.
    #[prost(message, optional, tag="2")]
    #[serde(with = "crate::serde_timestamp_optional")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The duration of the query.
    #[prost(message, optional, tag="3")]
    #[serde(with = "crate::serde_duration_optional")]
    pub execution_duration: ::core::option::Option<::prost_types::Duration>,
}
impl ::prost::Name for QueryStats {
const NAME: &'static str = "QueryStats";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.QueryStats".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.QueryStats".into() }}
/// Request to relate two records.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelateRequest {
    #[prost(message, optional, tag="1")]
    pub txn: ::core::option::Option<super::super::v1::Uuid>,
    #[prost(bool, tag="2")]
    pub only: bool,
    #[prost(message, optional, tag="3")]
    pub kind: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="4")]
    pub from: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="5")]
    pub with: ::core::option::Option<super::super::v1::Value>,
    #[prost(bool, tag="6")]
    pub uniq: bool,
    #[prost(message, optional, tag="7")]
    pub data: ::core::option::Option<super::super::v1::Data>,
    #[prost(message, optional, tag="8")]
    pub output: ::core::option::Option<super::super::v1::Output>,
    #[prost(message, optional, tag="9")]
    #[serde(with = "crate::serde_duration_optional")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag="10")]
    pub parallel: bool,
    #[prost(message, optional, tag="11")]
    pub variables: ::core::option::Option<Variables>,
}
impl ::prost::Name for RelateRequest {
const NAME: &'static str = "RelateRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.RelateRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.RelateRequest".into() }}
/// Response to a relate request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelateResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for RelateResponse {
const NAME: &'static str = "RelateResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.RelateResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.RelateResponse".into() }}
/// Request to run a function.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunFunctionRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="3")]
    pub args: ::prost::alloc::vec::Vec<super::super::v1::Value>,
}
impl ::prost::Name for RunFunctionRequest {
const NAME: &'static str = "RunFunctionRequest";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.RunFunctionRequest".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.RunFunctionRequest".into() }}
/// Response to a run function request.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunFunctionResponse {
    #[prost(message, optional, tag="1")]
    pub values: ::core::option::Option<ValueBatch>,
}
impl ::prost::Name for RunFunctionResponse {
const NAME: &'static str = "RunFunctionResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.RunFunctionResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.RunFunctionResponse".into() }}
/// Batch of values.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueBatch {
    #[prost(message, repeated, tag="1")]
    pub values: ::prost::alloc::vec::Vec<super::super::v1::Value>,
}
impl ::prost::Name for ValueBatch {
const NAME: &'static str = "ValueBatch";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.ValueBatch".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.ValueBatch".into() }}
/// Root user credentials.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RootUserCredentials {
    #[prost(string, tag="1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub password: ::prost::alloc::string::String,
}
impl ::prost::Name for RootUserCredentials {
const NAME: &'static str = "RootUserCredentials";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.RootUserCredentials".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.RootUserCredentials".into() }}
/// Namespace access credentials.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespaceAccessCredentials {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub access: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub key: ::prost::alloc::string::String,
}
impl ::prost::Name for NamespaceAccessCredentials {
const NAME: &'static str = "NamespaceAccessCredentials";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.NamespaceAccessCredentials".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.NamespaceAccessCredentials".into() }}
/// Database access credentials.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseAccessCredentials {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub database: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub access: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub refresh: ::prost::alloc::string::String,
}
impl ::prost::Name for DatabaseAccessCredentials {
const NAME: &'static str = "DatabaseAccessCredentials";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.DatabaseAccessCredentials".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.DatabaseAccessCredentials".into() }}
/// Namespace user credentials.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespaceUserCredentials {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub password: ::prost::alloc::string::String,
}
impl ::prost::Name for NamespaceUserCredentials {
const NAME: &'static str = "NamespaceUserCredentials";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.NamespaceUserCredentials".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.NamespaceUserCredentials".into() }}
/// Database user credentials.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseUserCredentials {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub database: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub password: ::prost::alloc::string::String,
}
impl ::prost::Name for DatabaseUserCredentials {
const NAME: &'static str = "DatabaseUserCredentials";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.DatabaseUserCredentials".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.DatabaseUserCredentials".into() }}
/// Access token.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessToken {
    #[prost(string, tag="1")]
    pub token: ::prost::alloc::string::String,
}
impl ::prost::Name for AccessToken {
const NAME: &'static str = "AccessToken";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.AccessToken".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.AccessToken".into() }}
/// Method of authenticating with the database.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessMethod {
    #[prost(oneof="access_method::Method", tags="1, 2, 3, 4, 5, 6")]
    pub method: ::core::option::Option<access_method::Method>,
}
/// Nested message and enum types in `AccessMethod`.
pub mod access_method {
    #[derive(serde::Deserialize,serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Method {
        #[prost(message, tag="1")]
        Root(super::RootUserCredentials),
        #[prost(message, tag="2")]
        Namespace(super::NamespaceAccessCredentials),
        #[prost(message, tag="3")]
        Database(super::DatabaseAccessCredentials),
        #[prost(message, tag="4")]
        NamespaceUser(super::NamespaceUserCredentials),
        #[prost(message, tag="5")]
        DatabaseUser(super::DatabaseUserCredentials),
        #[prost(message, tag="6")]
        AccessToken(super::AccessToken),
    }
}
impl ::prost::Name for AccessMethod {
const NAME: &'static str = "AccessMethod";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.AccessMethod".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.AccessMethod".into() }}
/// Response to a live query.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveResponse {
    #[prost(message, optional, tag="1")]
    pub id: ::core::option::Option<super::super::v1::Uuid>,
    #[prost(enumeration="Action", tag="2")]
    pub action: i32,
    #[prost(message, optional, tag="3")]
    pub record: ::core::option::Option<super::super::v1::Value>,
    #[prost(message, optional, tag="4")]
    pub result: ::core::option::Option<super::super::v1::Value>,
}
impl ::prost::Name for LiveResponse {
const NAME: &'static str = "LiveResponse";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.LiveResponse".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.LiveResponse".into() }}
/// Variables.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Variables {
    #[prost(btree_map="string, message", tag="1")]
    pub variables: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, super::super::v1::Value>,
}
impl ::prost::Name for Variables {
const NAME: &'static str = "Variables";
const PACKAGE: &'static str = "surrealdb.protocol.rpc.v1";
fn full_name() -> ::prost::alloc::string::String { "surrealdb.protocol.rpc.v1.Variables".into() }fn type_url() -> ::prost::alloc::string::String { "/surrealdb.protocol.rpc.v1.Variables".into() }}
/// Action type.
#[derive(serde::Deserialize,serde::Serialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Action {
    Unspecified = 0,
    Create = 1,
    Update = 2,
    Delete = 3,
    Killed = 4,
}
impl Action {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACTION_UNSPECIFIED",
            Self::Create => "ACTION_CREATE",
            Self::Update => "ACTION_UPDATE",
            Self::Delete => "ACTION_DELETE",
            Self::Killed => "ACTION_KILLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTION_CREATE" => Some(Self::Create),
            "ACTION_UPDATE" => Some(Self::Update),
            "ACTION_DELETE" => Some(Self::Delete),
            "ACTION_KILLED" => Some(Self::Killed),
            _ => None,
        }
    }
}
include!("surrealdb.protocol.rpc.v1.tonic.rs");
// @@protoc_insertion_point(module)